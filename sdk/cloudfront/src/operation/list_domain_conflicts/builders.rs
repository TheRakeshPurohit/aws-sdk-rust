// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
pub use crate::operation::list_domain_conflicts::_list_domain_conflicts_output::ListDomainConflictsOutputBuilder;

pub use crate::operation::list_domain_conflicts::_list_domain_conflicts_input::ListDomainConflictsInputBuilder;

impl crate::operation::list_domain_conflicts::builders::ListDomainConflictsInputBuilder {
    /// Sends a request with this input using the given client.
    pub async fn send_with(
        self,
        client: &crate::Client,
    ) -> ::std::result::Result<
        crate::operation::list_domain_conflicts::ListDomainConflictsOutput,
        ::aws_smithy_runtime_api::client::result::SdkError<
            crate::operation::list_domain_conflicts::ListDomainConflictsError,
            ::aws_smithy_runtime_api::client::orchestrator::HttpResponse,
        >,
    > {
        let mut fluent_builder = client.list_domain_conflicts();
        fluent_builder.inner = self;
        fluent_builder.send().await
    }
}
/// Fluent builder constructing a request to `ListDomainConflicts`.
///
/// <note>
/// <p>We recommend that you use the <code>ListDomainConflicts</code> API operation to check for domain conflicts, as it supports both standard distributions and distribution tenants. <a href="https://docs.aws.amazon.com/cloudfront/latest/APIReference/API_ListConflictingAliases.html">ListConflictingAliases</a> performs similar checks but only supports standard distributions.</p>
/// </note>
/// <p>Lists existing domain associations that conflict with the domain that you specify.</p>
/// <p>You can use this API operation to identify potential domain conflicts when moving domains between standard distributions and/or distribution tenants. Domain conflicts must be resolved first before they can be moved.</p>
/// <p>For example, if you provide <code>www.example.com</code> as input, the returned list can include <code>www.example.com</code> and the overlapping wildcard alternate domain name (<code>*.example.com</code>), if they exist. If you provide <code>*.example.com</code> as input, the returned list can include <code>*.example.com</code> and any alternate domain names covered by that wildcard (for example, <code>www.example.com</code>, <code>test.example.com</code>, <code>dev.example.com</code>, and so on), if they exist.</p>
/// <p>To list conflicting domains, specify the following:</p>
/// <ul>
/// <li>
/// <p>The domain to search for</p></li>
/// <li>
/// <p>The ID of a standard distribution or distribution tenant in your account that has an attached TLS certificate, which covers the specified domain</p></li>
/// </ul>
/// <p>For more information, including how to set up the standard distribution or distribution tenant, and the certificate, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/CNAMEs.html#alternate-domain-names-move">Moving an alternate domain name to a different standard distribution or distribution tenant</a> in the <i>Amazon CloudFront Developer Guide</i>.</p>
/// <p>You can optionally specify the maximum number of items to receive in the response. If the total number of items in the list exceeds the maximum that you specify, or the default maximum, the response is paginated. To get the next page of items, send a subsequent request that specifies the <code>NextMarker</code> value from the current response as the <code>Marker</code> value in the subsequent request.</p>
#[derive(::std::clone::Clone, ::std::fmt::Debug)]
pub struct ListDomainConflictsFluentBuilder {
    handle: ::std::sync::Arc<crate::client::Handle>,
    inner: crate::operation::list_domain_conflicts::builders::ListDomainConflictsInputBuilder,
    config_override: ::std::option::Option<crate::config::Builder>,
}
impl
    crate::client::customize::internal::CustomizableSend<
        crate::operation::list_domain_conflicts::ListDomainConflictsOutput,
        crate::operation::list_domain_conflicts::ListDomainConflictsError,
    > for ListDomainConflictsFluentBuilder
{
    fn send(
        self,
        config_override: crate::config::Builder,
    ) -> crate::client::customize::internal::BoxFuture<
        crate::client::customize::internal::SendResult<
            crate::operation::list_domain_conflicts::ListDomainConflictsOutput,
            crate::operation::list_domain_conflicts::ListDomainConflictsError,
        >,
    > {
        ::std::boxed::Box::pin(async move { self.config_override(config_override).send().await })
    }
}
impl ListDomainConflictsFluentBuilder {
    /// Creates a new `ListDomainConflictsFluentBuilder`.
    pub(crate) fn new(handle: ::std::sync::Arc<crate::client::Handle>) -> Self {
        Self {
            handle,
            inner: ::std::default::Default::default(),
            config_override: ::std::option::Option::None,
        }
    }
    /// Access the ListDomainConflicts as a reference.
    pub fn as_input(&self) -> &crate::operation::list_domain_conflicts::builders::ListDomainConflictsInputBuilder {
        &self.inner
    }
    /// Sends the request and returns the response.
    ///
    /// If an error occurs, an `SdkError` will be returned with additional details that
    /// can be matched against.
    ///
    /// By default, any retryable failures will be retried twice. Retry behavior
    /// is configurable with the [RetryConfig](aws_smithy_types::retry::RetryConfig), which can be
    /// set when configuring the client.
    pub async fn send(
        self,
    ) -> ::std::result::Result<
        crate::operation::list_domain_conflicts::ListDomainConflictsOutput,
        ::aws_smithy_runtime_api::client::result::SdkError<
            crate::operation::list_domain_conflicts::ListDomainConflictsError,
            ::aws_smithy_runtime_api::client::orchestrator::HttpResponse,
        >,
    > {
        let input = self
            .inner
            .build()
            .map_err(::aws_smithy_runtime_api::client::result::SdkError::construction_failure)?;
        let runtime_plugins = crate::operation::list_domain_conflicts::ListDomainConflicts::operation_runtime_plugins(
            self.handle.runtime_plugins.clone(),
            &self.handle.conf,
            self.config_override,
        );
        crate::operation::list_domain_conflicts::ListDomainConflicts::orchestrate(&runtime_plugins, input).await
    }

    /// Consumes this builder, creating a customizable operation that can be modified before being sent.
    pub fn customize(
        self,
    ) -> crate::client::customize::CustomizableOperation<
        crate::operation::list_domain_conflicts::ListDomainConflictsOutput,
        crate::operation::list_domain_conflicts::ListDomainConflictsError,
        Self,
    > {
        crate::client::customize::CustomizableOperation::new(self)
    }
    pub(crate) fn config_override(mut self, config_override: impl ::std::convert::Into<crate::config::Builder>) -> Self {
        self.set_config_override(::std::option::Option::Some(config_override.into()));
        self
    }

    pub(crate) fn set_config_override(&mut self, config_override: ::std::option::Option<crate::config::Builder>) -> &mut Self {
        self.config_override = config_override;
        self
    }
    /// Create a paginator for this request
    ///
    /// Paginators are used by calling [`send().await`](crate::operation::list_domain_conflicts::paginator::ListDomainConflictsPaginator::send) which returns a [`PaginationStream`](aws_smithy_async::future::pagination_stream::PaginationStream).
    pub fn into_paginator(self) -> crate::operation::list_domain_conflicts::paginator::ListDomainConflictsPaginator {
        crate::operation::list_domain_conflicts::paginator::ListDomainConflictsPaginator::new(self.handle, self.inner)
    }
    /// <p>The domain to check for conflicts.</p>
    pub fn domain(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.inner = self.inner.domain(input.into());
        self
    }
    /// <p>The domain to check for conflicts.</p>
    pub fn set_domain(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.inner = self.inner.set_domain(input);
        self
    }
    /// <p>The domain to check for conflicts.</p>
    pub fn get_domain(&self) -> &::std::option::Option<::std::string::String> {
        self.inner.get_domain()
    }
    /// <p>The distribution resource identifier. This can be the standard distribution or distribution tenant that has a valid certificate, which covers the domain that you specify.</p>
    pub fn domain_control_validation_resource(mut self, input: crate::types::DistributionResourceId) -> Self {
        self.inner = self.inner.domain_control_validation_resource(input);
        self
    }
    /// <p>The distribution resource identifier. This can be the standard distribution or distribution tenant that has a valid certificate, which covers the domain that you specify.</p>
    pub fn set_domain_control_validation_resource(mut self, input: ::std::option::Option<crate::types::DistributionResourceId>) -> Self {
        self.inner = self.inner.set_domain_control_validation_resource(input);
        self
    }
    /// <p>The distribution resource identifier. This can be the standard distribution or distribution tenant that has a valid certificate, which covers the domain that you specify.</p>
    pub fn get_domain_control_validation_resource(&self) -> &::std::option::Option<crate::types::DistributionResourceId> {
        self.inner.get_domain_control_validation_resource()
    }
    /// <p>The maximum number of domain conflicts to return.</p>
    pub fn max_items(mut self, input: i32) -> Self {
        self.inner = self.inner.max_items(input);
        self
    }
    /// <p>The maximum number of domain conflicts to return.</p>
    pub fn set_max_items(mut self, input: ::std::option::Option<i32>) -> Self {
        self.inner = self.inner.set_max_items(input);
        self
    }
    /// <p>The maximum number of domain conflicts to return.</p>
    pub fn get_max_items(&self) -> &::std::option::Option<i32> {
        self.inner.get_max_items()
    }
    /// <p>The marker for the next set of domain conflicts.</p>
    pub fn marker(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.inner = self.inner.marker(input.into());
        self
    }
    /// <p>The marker for the next set of domain conflicts.</p>
    pub fn set_marker(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.inner = self.inner.set_marker(input);
        self
    }
    /// <p>The marker for the next set of domain conflicts.</p>
    pub fn get_marker(&self) -> &::std::option::Option<::std::string::String> {
        self.inner.get_marker()
    }
}
