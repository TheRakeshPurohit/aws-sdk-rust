// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
pub fn ser_object_encryption_filter(
    input: &crate::types::ObjectEncryptionFilter,
    writer: ::aws_smithy_xml::encode::ElWriter,
) -> ::std::result::Result<(), ::aws_smithy_types::error::operation::SerializationError> {
    let mut scope_writer = writer.finish();
    match input {
        crate::types::ObjectEncryptionFilter::Sses3(inner) => {
            scope_writer.start_el("SSE-S3").finish();
        }
        crate::types::ObjectEncryptionFilter::Ssekms(inner) => {
            let inner_writer = scope_writer.start_el("SSE-KMS");
            crate::protocol_serde::shape_ssekms_filter::ser_ssekms_filter(inner, inner_writer)?
        }
        crate::types::ObjectEncryptionFilter::Dssekms(inner) => {
            let inner_writer = scope_writer.start_el("DSSE-KMS");
            crate::protocol_serde::shape_dssekms_filter::ser_dssekms_filter(inner, inner_writer)?
        }
        crate::types::ObjectEncryptionFilter::Ssec(inner) => {
            scope_writer.start_el("SSE-C").finish();
        }
        crate::types::ObjectEncryptionFilter::Notsse(inner) => {
            scope_writer.start_el("NOT-SSE").finish();
        }
        crate::types::ObjectEncryptionFilter::Unknown => {
            return Err(::aws_smithy_types::error::operation::SerializationError::unknown_variant(
                "ObjectEncryptionFilter",
            ))
        }
    }
    Ok(())
}

pub fn de_object_encryption_filter(
    decoder: &mut ::aws_smithy_xml::decode::ScopedDecoder,
) -> ::std::result::Result<crate::types::ObjectEncryptionFilter, ::aws_smithy_xml::decode::XmlDecodeError> {
    let mut base: Option<crate::types::ObjectEncryptionFilter> = None;
    while let Some(mut tag) = decoder.next_tag() {
        match tag.start_el() {
            s if s.matches("SSE-S3") /* SSES3 com.amazonaws.s3control#ObjectEncryptionFilter$SSES3 */ =>  {
                let tmp =
                    crate::protocol_serde::shape_sses3_filter::de_sses3_filter(&mut tag)
                    ?
                ;
                base = Some(crate::types::ObjectEncryptionFilter::Sses3(tmp));
            }
            ,
            s if s.matches("SSE-KMS") /* SSEKMS com.amazonaws.s3control#ObjectEncryptionFilter$SSEKMS */ =>  {
                let tmp =
                    crate::protocol_serde::shape_ssekms_filter::de_ssekms_filter(&mut tag)
                    ?
                ;
                base = Some(crate::types::ObjectEncryptionFilter::Ssekms(tmp));
            }
            ,
            s if s.matches("DSSE-KMS") /* DSSEKMS com.amazonaws.s3control#ObjectEncryptionFilter$DSSEKMS */ =>  {
                let tmp =
                    crate::protocol_serde::shape_dssekms_filter::de_dssekms_filter(&mut tag)
                    ?
                ;
                base = Some(crate::types::ObjectEncryptionFilter::Dssekms(tmp));
            }
            ,
            s if s.matches("SSE-C") /* SSEC com.amazonaws.s3control#ObjectEncryptionFilter$SSEC */ =>  {
                let tmp =
                    crate::protocol_serde::shape_ssec_filter::de_ssec_filter(&mut tag)
                    ?
                ;
                base = Some(crate::types::ObjectEncryptionFilter::Ssec(tmp));
            }
            ,
            s if s.matches("NOT-SSE") /* NOTSSE com.amazonaws.s3control#ObjectEncryptionFilter$NOTSSE */ =>  {
                let tmp =
                    crate::protocol_serde::shape_not_sse_filter::de_not_sse_filter(&mut tag)
                    ?
                ;
                base = Some(crate::types::ObjectEncryptionFilter::Notsse(tmp));
            }
            ,
            _unknown => base = Some(crate::types::ObjectEncryptionFilter::Unknown),
        }
    }
    base.ok_or_else(|| ::aws_smithy_xml::decode::XmlDecodeError::custom("expected union, got nothing"))
}
