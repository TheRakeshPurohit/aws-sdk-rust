// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::fmt::Debug)]
pub struct ListVectorsInput {
    /// <p>The name of the vector bucket.</p>
    pub vector_bucket_name: ::std::option::Option<::std::string::String>,
    /// <p>The name of the vector index.</p>
    pub index_name: ::std::option::Option<::std::string::String>,
    /// <p>The Amazon resource Name (ARN) of the vector index.</p>
    pub index_arn: ::std::option::Option<::std::string::String>,
    /// <p>The maximum number of vectors to return on a page.</p>
    /// <p>If you don't specify <code>maxResults</code>, the <code>ListVectors</code> operation uses a default value of 500.</p>
    /// <p>If the processed dataset size exceeds 1 MB before reaching the <code>maxResults</code> value, the operation stops and returns the vectors that are retrieved up to that point, along with a <code>nextToken</code> that you can use in a subsequent request to retrieve the next set of results.</p>
    pub max_results: ::std::option::Option<i32>,
    /// <p>Pagination token from a previous request. The value of this field is empty for an initial request.</p>
    pub next_token: ::std::option::Option<::std::string::String>,
    /// <p>For a parallel <code>ListVectors</code> request, <code>segmentCount</code> represents the total number of vector segments into which the <code>ListVectors</code> operation will be divided. The value of <code>segmentCount</code> corresponds to the number of application workers that will perform the parallel <code>ListVectors</code> operation. For example, if you want to use four application threads to list vectors in a vector index, specify a <code>segmentCount</code> value of 4.</p>
    /// <p>If you specify a <code>segmentCount</code> value of 1, the <code>ListVectors</code> operation will be sequential rather than parallel.</p>
    /// <p>If you specify <code>segmentCount</code>, you must also specify <code>segmentIndex</code>.</p>
    pub segment_count: ::std::option::Option<i32>,
    /// <p>For a parallel <code>ListVectors</code> request, <code>segmentIndex</code> is the index of the segment from which to list vectors in the current request. It identifies an individual segment to be listed by an application worker.</p>
    /// <p>Segment IDs are zero-based, so the first segment is always 0. For example, if you want to use four application threads to list vectors in a vector index, then the first thread specifies a <code>segmentIndex</code> value of 0, the second thread specifies 1, and so on.</p>
    /// <p>The value of <code>segmentIndex</code> must be less than the value provided for <code>segmentCount</code>.</p>
    /// <p>If you provide <code>segmentIndex</code>, you must also provide <code>segmentCount</code>.</p>
    pub segment_index: ::std::option::Option<i32>,
    /// <p>If true, the vector data of each vector will be included in the response. The default value is <code>false</code>.</p>
    pub return_data: ::std::option::Option<bool>,
    /// <p>If true, the metadata associated with each vector will be included in the response. The default value is <code>false</code>.</p>
    pub return_metadata: ::std::option::Option<bool>,
}
impl ListVectorsInput {
    /// <p>The name of the vector bucket.</p>
    pub fn vector_bucket_name(&self) -> ::std::option::Option<&str> {
        self.vector_bucket_name.as_deref()
    }
    /// <p>The name of the vector index.</p>
    pub fn index_name(&self) -> ::std::option::Option<&str> {
        self.index_name.as_deref()
    }
    /// <p>The Amazon resource Name (ARN) of the vector index.</p>
    pub fn index_arn(&self) -> ::std::option::Option<&str> {
        self.index_arn.as_deref()
    }
    /// <p>The maximum number of vectors to return on a page.</p>
    /// <p>If you don't specify <code>maxResults</code>, the <code>ListVectors</code> operation uses a default value of 500.</p>
    /// <p>If the processed dataset size exceeds 1 MB before reaching the <code>maxResults</code> value, the operation stops and returns the vectors that are retrieved up to that point, along with a <code>nextToken</code> that you can use in a subsequent request to retrieve the next set of results.</p>
    pub fn max_results(&self) -> ::std::option::Option<i32> {
        self.max_results
    }
    /// <p>Pagination token from a previous request. The value of this field is empty for an initial request.</p>
    pub fn next_token(&self) -> ::std::option::Option<&str> {
        self.next_token.as_deref()
    }
    /// <p>For a parallel <code>ListVectors</code> request, <code>segmentCount</code> represents the total number of vector segments into which the <code>ListVectors</code> operation will be divided. The value of <code>segmentCount</code> corresponds to the number of application workers that will perform the parallel <code>ListVectors</code> operation. For example, if you want to use four application threads to list vectors in a vector index, specify a <code>segmentCount</code> value of 4.</p>
    /// <p>If you specify a <code>segmentCount</code> value of 1, the <code>ListVectors</code> operation will be sequential rather than parallel.</p>
    /// <p>If you specify <code>segmentCount</code>, you must also specify <code>segmentIndex</code>.</p>
    pub fn segment_count(&self) -> ::std::option::Option<i32> {
        self.segment_count
    }
    /// <p>For a parallel <code>ListVectors</code> request, <code>segmentIndex</code> is the index of the segment from which to list vectors in the current request. It identifies an individual segment to be listed by an application worker.</p>
    /// <p>Segment IDs are zero-based, so the first segment is always 0. For example, if you want to use four application threads to list vectors in a vector index, then the first thread specifies a <code>segmentIndex</code> value of 0, the second thread specifies 1, and so on.</p>
    /// <p>The value of <code>segmentIndex</code> must be less than the value provided for <code>segmentCount</code>.</p>
    /// <p>If you provide <code>segmentIndex</code>, you must also provide <code>segmentCount</code>.</p>
    pub fn segment_index(&self) -> ::std::option::Option<i32> {
        self.segment_index
    }
    /// <p>If true, the vector data of each vector will be included in the response. The default value is <code>false</code>.</p>
    pub fn return_data(&self) -> ::std::option::Option<bool> {
        self.return_data
    }
    /// <p>If true, the metadata associated with each vector will be included in the response. The default value is <code>false</code>.</p>
    pub fn return_metadata(&self) -> ::std::option::Option<bool> {
        self.return_metadata
    }
}
impl ListVectorsInput {
    /// Creates a new builder-style object to manufacture [`ListVectorsInput`](crate::operation::list_vectors::ListVectorsInput).
    pub fn builder() -> crate::operation::list_vectors::builders::ListVectorsInputBuilder {
        crate::operation::list_vectors::builders::ListVectorsInputBuilder::default()
    }
}

/// A builder for [`ListVectorsInput`](crate::operation::list_vectors::ListVectorsInput).
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::default::Default, ::std::fmt::Debug)]
#[non_exhaustive]
pub struct ListVectorsInputBuilder {
    pub(crate) vector_bucket_name: ::std::option::Option<::std::string::String>,
    pub(crate) index_name: ::std::option::Option<::std::string::String>,
    pub(crate) index_arn: ::std::option::Option<::std::string::String>,
    pub(crate) max_results: ::std::option::Option<i32>,
    pub(crate) next_token: ::std::option::Option<::std::string::String>,
    pub(crate) segment_count: ::std::option::Option<i32>,
    pub(crate) segment_index: ::std::option::Option<i32>,
    pub(crate) return_data: ::std::option::Option<bool>,
    pub(crate) return_metadata: ::std::option::Option<bool>,
}
impl ListVectorsInputBuilder {
    /// <p>The name of the vector bucket.</p>
    pub fn vector_bucket_name(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.vector_bucket_name = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The name of the vector bucket.</p>
    pub fn set_vector_bucket_name(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.vector_bucket_name = input;
        self
    }
    /// <p>The name of the vector bucket.</p>
    pub fn get_vector_bucket_name(&self) -> &::std::option::Option<::std::string::String> {
        &self.vector_bucket_name
    }
    /// <p>The name of the vector index.</p>
    pub fn index_name(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.index_name = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The name of the vector index.</p>
    pub fn set_index_name(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.index_name = input;
        self
    }
    /// <p>The name of the vector index.</p>
    pub fn get_index_name(&self) -> &::std::option::Option<::std::string::String> {
        &self.index_name
    }
    /// <p>The Amazon resource Name (ARN) of the vector index.</p>
    pub fn index_arn(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.index_arn = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The Amazon resource Name (ARN) of the vector index.</p>
    pub fn set_index_arn(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.index_arn = input;
        self
    }
    /// <p>The Amazon resource Name (ARN) of the vector index.</p>
    pub fn get_index_arn(&self) -> &::std::option::Option<::std::string::String> {
        &self.index_arn
    }
    /// <p>The maximum number of vectors to return on a page.</p>
    /// <p>If you don't specify <code>maxResults</code>, the <code>ListVectors</code> operation uses a default value of 500.</p>
    /// <p>If the processed dataset size exceeds 1 MB before reaching the <code>maxResults</code> value, the operation stops and returns the vectors that are retrieved up to that point, along with a <code>nextToken</code> that you can use in a subsequent request to retrieve the next set of results.</p>
    pub fn max_results(mut self, input: i32) -> Self {
        self.max_results = ::std::option::Option::Some(input);
        self
    }
    /// <p>The maximum number of vectors to return on a page.</p>
    /// <p>If you don't specify <code>maxResults</code>, the <code>ListVectors</code> operation uses a default value of 500.</p>
    /// <p>If the processed dataset size exceeds 1 MB before reaching the <code>maxResults</code> value, the operation stops and returns the vectors that are retrieved up to that point, along with a <code>nextToken</code> that you can use in a subsequent request to retrieve the next set of results.</p>
    pub fn set_max_results(mut self, input: ::std::option::Option<i32>) -> Self {
        self.max_results = input;
        self
    }
    /// <p>The maximum number of vectors to return on a page.</p>
    /// <p>If you don't specify <code>maxResults</code>, the <code>ListVectors</code> operation uses a default value of 500.</p>
    /// <p>If the processed dataset size exceeds 1 MB before reaching the <code>maxResults</code> value, the operation stops and returns the vectors that are retrieved up to that point, along with a <code>nextToken</code> that you can use in a subsequent request to retrieve the next set of results.</p>
    pub fn get_max_results(&self) -> &::std::option::Option<i32> {
        &self.max_results
    }
    /// <p>Pagination token from a previous request. The value of this field is empty for an initial request.</p>
    pub fn next_token(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.next_token = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>Pagination token from a previous request. The value of this field is empty for an initial request.</p>
    pub fn set_next_token(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.next_token = input;
        self
    }
    /// <p>Pagination token from a previous request. The value of this field is empty for an initial request.</p>
    pub fn get_next_token(&self) -> &::std::option::Option<::std::string::String> {
        &self.next_token
    }
    /// <p>For a parallel <code>ListVectors</code> request, <code>segmentCount</code> represents the total number of vector segments into which the <code>ListVectors</code> operation will be divided. The value of <code>segmentCount</code> corresponds to the number of application workers that will perform the parallel <code>ListVectors</code> operation. For example, if you want to use four application threads to list vectors in a vector index, specify a <code>segmentCount</code> value of 4.</p>
    /// <p>If you specify a <code>segmentCount</code> value of 1, the <code>ListVectors</code> operation will be sequential rather than parallel.</p>
    /// <p>If you specify <code>segmentCount</code>, you must also specify <code>segmentIndex</code>.</p>
    pub fn segment_count(mut self, input: i32) -> Self {
        self.segment_count = ::std::option::Option::Some(input);
        self
    }
    /// <p>For a parallel <code>ListVectors</code> request, <code>segmentCount</code> represents the total number of vector segments into which the <code>ListVectors</code> operation will be divided. The value of <code>segmentCount</code> corresponds to the number of application workers that will perform the parallel <code>ListVectors</code> operation. For example, if you want to use four application threads to list vectors in a vector index, specify a <code>segmentCount</code> value of 4.</p>
    /// <p>If you specify a <code>segmentCount</code> value of 1, the <code>ListVectors</code> operation will be sequential rather than parallel.</p>
    /// <p>If you specify <code>segmentCount</code>, you must also specify <code>segmentIndex</code>.</p>
    pub fn set_segment_count(mut self, input: ::std::option::Option<i32>) -> Self {
        self.segment_count = input;
        self
    }
    /// <p>For a parallel <code>ListVectors</code> request, <code>segmentCount</code> represents the total number of vector segments into which the <code>ListVectors</code> operation will be divided. The value of <code>segmentCount</code> corresponds to the number of application workers that will perform the parallel <code>ListVectors</code> operation. For example, if you want to use four application threads to list vectors in a vector index, specify a <code>segmentCount</code> value of 4.</p>
    /// <p>If you specify a <code>segmentCount</code> value of 1, the <code>ListVectors</code> operation will be sequential rather than parallel.</p>
    /// <p>If you specify <code>segmentCount</code>, you must also specify <code>segmentIndex</code>.</p>
    pub fn get_segment_count(&self) -> &::std::option::Option<i32> {
        &self.segment_count
    }
    /// <p>For a parallel <code>ListVectors</code> request, <code>segmentIndex</code> is the index of the segment from which to list vectors in the current request. It identifies an individual segment to be listed by an application worker.</p>
    /// <p>Segment IDs are zero-based, so the first segment is always 0. For example, if you want to use four application threads to list vectors in a vector index, then the first thread specifies a <code>segmentIndex</code> value of 0, the second thread specifies 1, and so on.</p>
    /// <p>The value of <code>segmentIndex</code> must be less than the value provided for <code>segmentCount</code>.</p>
    /// <p>If you provide <code>segmentIndex</code>, you must also provide <code>segmentCount</code>.</p>
    pub fn segment_index(mut self, input: i32) -> Self {
        self.segment_index = ::std::option::Option::Some(input);
        self
    }
    /// <p>For a parallel <code>ListVectors</code> request, <code>segmentIndex</code> is the index of the segment from which to list vectors in the current request. It identifies an individual segment to be listed by an application worker.</p>
    /// <p>Segment IDs are zero-based, so the first segment is always 0. For example, if you want to use four application threads to list vectors in a vector index, then the first thread specifies a <code>segmentIndex</code> value of 0, the second thread specifies 1, and so on.</p>
    /// <p>The value of <code>segmentIndex</code> must be less than the value provided for <code>segmentCount</code>.</p>
    /// <p>If you provide <code>segmentIndex</code>, you must also provide <code>segmentCount</code>.</p>
    pub fn set_segment_index(mut self, input: ::std::option::Option<i32>) -> Self {
        self.segment_index = input;
        self
    }
    /// <p>For a parallel <code>ListVectors</code> request, <code>segmentIndex</code> is the index of the segment from which to list vectors in the current request. It identifies an individual segment to be listed by an application worker.</p>
    /// <p>Segment IDs are zero-based, so the first segment is always 0. For example, if you want to use four application threads to list vectors in a vector index, then the first thread specifies a <code>segmentIndex</code> value of 0, the second thread specifies 1, and so on.</p>
    /// <p>The value of <code>segmentIndex</code> must be less than the value provided for <code>segmentCount</code>.</p>
    /// <p>If you provide <code>segmentIndex</code>, you must also provide <code>segmentCount</code>.</p>
    pub fn get_segment_index(&self) -> &::std::option::Option<i32> {
        &self.segment_index
    }
    /// <p>If true, the vector data of each vector will be included in the response. The default value is <code>false</code>.</p>
    pub fn return_data(mut self, input: bool) -> Self {
        self.return_data = ::std::option::Option::Some(input);
        self
    }
    /// <p>If true, the vector data of each vector will be included in the response. The default value is <code>false</code>.</p>
    pub fn set_return_data(mut self, input: ::std::option::Option<bool>) -> Self {
        self.return_data = input;
        self
    }
    /// <p>If true, the vector data of each vector will be included in the response. The default value is <code>false</code>.</p>
    pub fn get_return_data(&self) -> &::std::option::Option<bool> {
        &self.return_data
    }
    /// <p>If true, the metadata associated with each vector will be included in the response. The default value is <code>false</code>.</p>
    pub fn return_metadata(mut self, input: bool) -> Self {
        self.return_metadata = ::std::option::Option::Some(input);
        self
    }
    /// <p>If true, the metadata associated with each vector will be included in the response. The default value is <code>false</code>.</p>
    pub fn set_return_metadata(mut self, input: ::std::option::Option<bool>) -> Self {
        self.return_metadata = input;
        self
    }
    /// <p>If true, the metadata associated with each vector will be included in the response. The default value is <code>false</code>.</p>
    pub fn get_return_metadata(&self) -> &::std::option::Option<bool> {
        &self.return_metadata
    }
    /// Consumes the builder and constructs a [`ListVectorsInput`](crate::operation::list_vectors::ListVectorsInput).
    pub fn build(self) -> ::std::result::Result<crate::operation::list_vectors::ListVectorsInput, ::aws_smithy_types::error::operation::BuildError> {
        ::std::result::Result::Ok(crate::operation::list_vectors::ListVectorsInput {
            vector_bucket_name: self.vector_bucket_name,
            index_name: self.index_name,
            index_arn: self.index_arn,
            max_results: self.max_results,
            next_token: self.next_token,
            segment_count: self.segment_count,
            segment_index: self.segment_index,
            return_data: self.return_data,
            return_metadata: self.return_metadata,
        })
    }
}
