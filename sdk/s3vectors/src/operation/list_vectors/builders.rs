// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
pub use crate::operation::list_vectors::_list_vectors_output::ListVectorsOutputBuilder;

pub use crate::operation::list_vectors::_list_vectors_input::ListVectorsInputBuilder;

impl crate::operation::list_vectors::builders::ListVectorsInputBuilder {
    /// Sends a request with this input using the given client.
    pub async fn send_with(
        self,
        client: &crate::Client,
    ) -> ::std::result::Result<
        crate::operation::list_vectors::ListVectorsOutput,
        ::aws_smithy_runtime_api::client::result::SdkError<
            crate::operation::list_vectors::ListVectorsError,
            ::aws_smithy_runtime_api::client::orchestrator::HttpResponse,
        >,
    > {
        let mut fluent_builder = client.list_vectors();
        fluent_builder.inner = self;
        fluent_builder.send().await
    }
}
/// Fluent builder constructing a request to `ListVectors`.
///
/// <note>
/// <p>Amazon S3 Vectors is in preview release for Amazon S3 and is subject to change.</p>
/// </note>
/// <p>List vectors in the specified vector index. To specify the vector index, you can either use both the vector bucket name and the vector index name, or use the vector index Amazon Resource Name (ARN).</p>
/// <p><code>ListVectors</code> operations proceed sequentially; however, for faster performance on a large number of vectors in a vector index, applications can request a parallel <code>ListVectors</code> operation by providing the <code>segmentCount</code> and <code>segmentIndex</code> parameters.</p>
/// <dl>
/// <dt>
/// Permissions
/// </dt>
/// <dd>
/// <p>You must have the <code>s3vectors:ListVectors</code> permission to use this operation. Additional permissions are required based on the request parameters you specify:</p>
/// <ul>
/// <li>
/// <p>With only <code>s3vectors:ListVectors</code> permission, you can list vector keys when <code>returnData</code> and <code>returnMetadata</code> are both set to false or not specified..</p></li>
/// <li>
/// <p>If you set <code>returnData</code> or <code>returnMetadata</code> to true, you must have both <code>s3vectors:ListVectors</code> and <code>s3vectors:GetVectors</code> permissions. The request fails with a <code>403 Forbidden</code> error if you request vector data or metadata without the <code>s3vectors:GetVectors</code> permission.</p></li>
/// </ul>
/// </dd>
/// </dl>
#[derive(::std::clone::Clone, ::std::fmt::Debug)]
pub struct ListVectorsFluentBuilder {
    handle: ::std::sync::Arc<crate::client::Handle>,
    inner: crate::operation::list_vectors::builders::ListVectorsInputBuilder,
    config_override: ::std::option::Option<crate::config::Builder>,
}
impl
    crate::client::customize::internal::CustomizableSend<
        crate::operation::list_vectors::ListVectorsOutput,
        crate::operation::list_vectors::ListVectorsError,
    > for ListVectorsFluentBuilder
{
    fn send(
        self,
        config_override: crate::config::Builder,
    ) -> crate::client::customize::internal::BoxFuture<
        crate::client::customize::internal::SendResult<
            crate::operation::list_vectors::ListVectorsOutput,
            crate::operation::list_vectors::ListVectorsError,
        >,
    > {
        ::std::boxed::Box::pin(async move { self.config_override(config_override).send().await })
    }
}
impl ListVectorsFluentBuilder {
    /// Creates a new `ListVectorsFluentBuilder`.
    pub(crate) fn new(handle: ::std::sync::Arc<crate::client::Handle>) -> Self {
        Self {
            handle,
            inner: ::std::default::Default::default(),
            config_override: ::std::option::Option::None,
        }
    }
    /// Access the ListVectors as a reference.
    pub fn as_input(&self) -> &crate::operation::list_vectors::builders::ListVectorsInputBuilder {
        &self.inner
    }
    /// Sends the request and returns the response.
    ///
    /// If an error occurs, an `SdkError` will be returned with additional details that
    /// can be matched against.
    ///
    /// By default, any retryable failures will be retried twice. Retry behavior
    /// is configurable with the [RetryConfig](aws_smithy_types::retry::RetryConfig), which can be
    /// set when configuring the client.
    pub async fn send(
        self,
    ) -> ::std::result::Result<
        crate::operation::list_vectors::ListVectorsOutput,
        ::aws_smithy_runtime_api::client::result::SdkError<
            crate::operation::list_vectors::ListVectorsError,
            ::aws_smithy_runtime_api::client::orchestrator::HttpResponse,
        >,
    > {
        let input = self
            .inner
            .build()
            .map_err(::aws_smithy_runtime_api::client::result::SdkError::construction_failure)?;
        let runtime_plugins = crate::operation::list_vectors::ListVectors::operation_runtime_plugins(
            self.handle.runtime_plugins.clone(),
            &self.handle.conf,
            self.config_override,
        );
        crate::operation::list_vectors::ListVectors::orchestrate(&runtime_plugins, input).await
    }

    /// Consumes this builder, creating a customizable operation that can be modified before being sent.
    pub fn customize(
        self,
    ) -> crate::client::customize::CustomizableOperation<
        crate::operation::list_vectors::ListVectorsOutput,
        crate::operation::list_vectors::ListVectorsError,
        Self,
    > {
        crate::client::customize::CustomizableOperation::new(self)
    }
    pub(crate) fn config_override(mut self, config_override: impl ::std::convert::Into<crate::config::Builder>) -> Self {
        self.set_config_override(::std::option::Option::Some(config_override.into()));
        self
    }

    pub(crate) fn set_config_override(&mut self, config_override: ::std::option::Option<crate::config::Builder>) -> &mut Self {
        self.config_override = config_override;
        self
    }
    /// Create a paginator for this request
    ///
    /// Paginators are used by calling [`send().await`](crate::operation::list_vectors::paginator::ListVectorsPaginator::send) which returns a [`PaginationStream`](aws_smithy_async::future::pagination_stream::PaginationStream).
    pub fn into_paginator(self) -> crate::operation::list_vectors::paginator::ListVectorsPaginator {
        crate::operation::list_vectors::paginator::ListVectorsPaginator::new(self.handle, self.inner)
    }
    /// <p>The name of the vector bucket.</p>
    pub fn vector_bucket_name(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.inner = self.inner.vector_bucket_name(input.into());
        self
    }
    /// <p>The name of the vector bucket.</p>
    pub fn set_vector_bucket_name(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.inner = self.inner.set_vector_bucket_name(input);
        self
    }
    /// <p>The name of the vector bucket.</p>
    pub fn get_vector_bucket_name(&self) -> &::std::option::Option<::std::string::String> {
        self.inner.get_vector_bucket_name()
    }
    /// <p>The name of the vector index.</p>
    pub fn index_name(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.inner = self.inner.index_name(input.into());
        self
    }
    /// <p>The name of the vector index.</p>
    pub fn set_index_name(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.inner = self.inner.set_index_name(input);
        self
    }
    /// <p>The name of the vector index.</p>
    pub fn get_index_name(&self) -> &::std::option::Option<::std::string::String> {
        self.inner.get_index_name()
    }
    /// <p>The Amazon resource Name (ARN) of the vector index.</p>
    pub fn index_arn(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.inner = self.inner.index_arn(input.into());
        self
    }
    /// <p>The Amazon resource Name (ARN) of the vector index.</p>
    pub fn set_index_arn(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.inner = self.inner.set_index_arn(input);
        self
    }
    /// <p>The Amazon resource Name (ARN) of the vector index.</p>
    pub fn get_index_arn(&self) -> &::std::option::Option<::std::string::String> {
        self.inner.get_index_arn()
    }
    /// <p>The maximum number of vectors to return on a page.</p>
    /// <p>If you don't specify <code>maxResults</code>, the <code>ListVectors</code> operation uses a default value of 500.</p>
    /// <p>If the processed dataset size exceeds 1 MB before reaching the <code>maxResults</code> value, the operation stops and returns the vectors that are retrieved up to that point, along with a <code>nextToken</code> that you can use in a subsequent request to retrieve the next set of results.</p>
    pub fn max_results(mut self, input: i32) -> Self {
        self.inner = self.inner.max_results(input);
        self
    }
    /// <p>The maximum number of vectors to return on a page.</p>
    /// <p>If you don't specify <code>maxResults</code>, the <code>ListVectors</code> operation uses a default value of 500.</p>
    /// <p>If the processed dataset size exceeds 1 MB before reaching the <code>maxResults</code> value, the operation stops and returns the vectors that are retrieved up to that point, along with a <code>nextToken</code> that you can use in a subsequent request to retrieve the next set of results.</p>
    pub fn set_max_results(mut self, input: ::std::option::Option<i32>) -> Self {
        self.inner = self.inner.set_max_results(input);
        self
    }
    /// <p>The maximum number of vectors to return on a page.</p>
    /// <p>If you don't specify <code>maxResults</code>, the <code>ListVectors</code> operation uses a default value of 500.</p>
    /// <p>If the processed dataset size exceeds 1 MB before reaching the <code>maxResults</code> value, the operation stops and returns the vectors that are retrieved up to that point, along with a <code>nextToken</code> that you can use in a subsequent request to retrieve the next set of results.</p>
    pub fn get_max_results(&self) -> &::std::option::Option<i32> {
        self.inner.get_max_results()
    }
    /// <p>Pagination token from a previous request. The value of this field is empty for an initial request.</p>
    pub fn next_token(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.inner = self.inner.next_token(input.into());
        self
    }
    /// <p>Pagination token from a previous request. The value of this field is empty for an initial request.</p>
    pub fn set_next_token(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.inner = self.inner.set_next_token(input);
        self
    }
    /// <p>Pagination token from a previous request. The value of this field is empty for an initial request.</p>
    pub fn get_next_token(&self) -> &::std::option::Option<::std::string::String> {
        self.inner.get_next_token()
    }
    /// <p>For a parallel <code>ListVectors</code> request, <code>segmentCount</code> represents the total number of vector segments into which the <code>ListVectors</code> operation will be divided. The value of <code>segmentCount</code> corresponds to the number of application workers that will perform the parallel <code>ListVectors</code> operation. For example, if you want to use four application threads to list vectors in a vector index, specify a <code>segmentCount</code> value of 4.</p>
    /// <p>If you specify a <code>segmentCount</code> value of 1, the <code>ListVectors</code> operation will be sequential rather than parallel.</p>
    /// <p>If you specify <code>segmentCount</code>, you must also specify <code>segmentIndex</code>.</p>
    pub fn segment_count(mut self, input: i32) -> Self {
        self.inner = self.inner.segment_count(input);
        self
    }
    /// <p>For a parallel <code>ListVectors</code> request, <code>segmentCount</code> represents the total number of vector segments into which the <code>ListVectors</code> operation will be divided. The value of <code>segmentCount</code> corresponds to the number of application workers that will perform the parallel <code>ListVectors</code> operation. For example, if you want to use four application threads to list vectors in a vector index, specify a <code>segmentCount</code> value of 4.</p>
    /// <p>If you specify a <code>segmentCount</code> value of 1, the <code>ListVectors</code> operation will be sequential rather than parallel.</p>
    /// <p>If you specify <code>segmentCount</code>, you must also specify <code>segmentIndex</code>.</p>
    pub fn set_segment_count(mut self, input: ::std::option::Option<i32>) -> Self {
        self.inner = self.inner.set_segment_count(input);
        self
    }
    /// <p>For a parallel <code>ListVectors</code> request, <code>segmentCount</code> represents the total number of vector segments into which the <code>ListVectors</code> operation will be divided. The value of <code>segmentCount</code> corresponds to the number of application workers that will perform the parallel <code>ListVectors</code> operation. For example, if you want to use four application threads to list vectors in a vector index, specify a <code>segmentCount</code> value of 4.</p>
    /// <p>If you specify a <code>segmentCount</code> value of 1, the <code>ListVectors</code> operation will be sequential rather than parallel.</p>
    /// <p>If you specify <code>segmentCount</code>, you must also specify <code>segmentIndex</code>.</p>
    pub fn get_segment_count(&self) -> &::std::option::Option<i32> {
        self.inner.get_segment_count()
    }
    /// <p>For a parallel <code>ListVectors</code> request, <code>segmentIndex</code> is the index of the segment from which to list vectors in the current request. It identifies an individual segment to be listed by an application worker.</p>
    /// <p>Segment IDs are zero-based, so the first segment is always 0. For example, if you want to use four application threads to list vectors in a vector index, then the first thread specifies a <code>segmentIndex</code> value of 0, the second thread specifies 1, and so on.</p>
    /// <p>The value of <code>segmentIndex</code> must be less than the value provided for <code>segmentCount</code>.</p>
    /// <p>If you provide <code>segmentIndex</code>, you must also provide <code>segmentCount</code>.</p>
    pub fn segment_index(mut self, input: i32) -> Self {
        self.inner = self.inner.segment_index(input);
        self
    }
    /// <p>For a parallel <code>ListVectors</code> request, <code>segmentIndex</code> is the index of the segment from which to list vectors in the current request. It identifies an individual segment to be listed by an application worker.</p>
    /// <p>Segment IDs are zero-based, so the first segment is always 0. For example, if you want to use four application threads to list vectors in a vector index, then the first thread specifies a <code>segmentIndex</code> value of 0, the second thread specifies 1, and so on.</p>
    /// <p>The value of <code>segmentIndex</code> must be less than the value provided for <code>segmentCount</code>.</p>
    /// <p>If you provide <code>segmentIndex</code>, you must also provide <code>segmentCount</code>.</p>
    pub fn set_segment_index(mut self, input: ::std::option::Option<i32>) -> Self {
        self.inner = self.inner.set_segment_index(input);
        self
    }
    /// <p>For a parallel <code>ListVectors</code> request, <code>segmentIndex</code> is the index of the segment from which to list vectors in the current request. It identifies an individual segment to be listed by an application worker.</p>
    /// <p>Segment IDs are zero-based, so the first segment is always 0. For example, if you want to use four application threads to list vectors in a vector index, then the first thread specifies a <code>segmentIndex</code> value of 0, the second thread specifies 1, and so on.</p>
    /// <p>The value of <code>segmentIndex</code> must be less than the value provided for <code>segmentCount</code>.</p>
    /// <p>If you provide <code>segmentIndex</code>, you must also provide <code>segmentCount</code>.</p>
    pub fn get_segment_index(&self) -> &::std::option::Option<i32> {
        self.inner.get_segment_index()
    }
    /// <p>If true, the vector data of each vector will be included in the response. The default value is <code>false</code>.</p>
    pub fn return_data(mut self, input: bool) -> Self {
        self.inner = self.inner.return_data(input);
        self
    }
    /// <p>If true, the vector data of each vector will be included in the response. The default value is <code>false</code>.</p>
    pub fn set_return_data(mut self, input: ::std::option::Option<bool>) -> Self {
        self.inner = self.inner.set_return_data(input);
        self
    }
    /// <p>If true, the vector data of each vector will be included in the response. The default value is <code>false</code>.</p>
    pub fn get_return_data(&self) -> &::std::option::Option<bool> {
        self.inner.get_return_data()
    }
    /// <p>If true, the metadata associated with each vector will be included in the response. The default value is <code>false</code>.</p>
    pub fn return_metadata(mut self, input: bool) -> Self {
        self.inner = self.inner.return_metadata(input);
        self
    }
    /// <p>If true, the metadata associated with each vector will be included in the response. The default value is <code>false</code>.</p>
    pub fn set_return_metadata(mut self, input: ::std::option::Option<bool>) -> Self {
        self.inner = self.inner.set_return_metadata(input);
        self
    }
    /// <p>If true, the metadata associated with each vector will be included in the response. The default value is <code>false</code>.</p>
    pub fn get_return_metadata(&self) -> &::std::option::Option<bool> {
        self.inner.get_return_metadata()
    }
}
