// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.

/// <p>Parameter information of a TR31KeyBlock wrapped using an ECDH derived key.</p>
#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq)]
pub struct IncomingDiffieHellmanTr31KeyBlock {
    /// <p>The <code>keyARN</code> of the asymmetric ECC key pair.</p>
    pub private_key_identifier: ::std::string::String,
    /// <p>The <code>keyArn</code> of the certificate that signed the client's <code>PublicKeyCertificate</code>.</p>
    pub certificate_authority_public_key_identifier: ::std::string::String,
    /// <p>The client's public key certificate in PEM format (base64 encoded) to use for ECDH key derivation.</p>
    pub public_key_certificate: ::std::string::String,
    /// <p>The key algorithm of the derived ECDH key.</p>
    pub derive_key_algorithm: crate::types::SymmetricKeyAlgorithm,
    /// <p>The key derivation function to use for deriving a key using ECDH.</p>
    pub key_derivation_function: crate::types::KeyDerivationFunction,
    /// <p>The hash type to use for deriving a key using ECDH.</p>
    pub key_derivation_hash_algorithm: crate::types::KeyDerivationHashAlgorithm,
    /// <p>The shared information used when deriving a key using ECDH.</p>
    pub derivation_data: ::std::option::Option<crate::types::DiffieHellmanDerivationData>,
    /// <p>The WrappedKeyBlock containing the transaction key wrapped using an ECDH dervied key.</p>
    pub wrapped_key_block: ::std::string::String,
}
impl IncomingDiffieHellmanTr31KeyBlock {
    /// <p>The <code>keyARN</code> of the asymmetric ECC key pair.</p>
    pub fn private_key_identifier(&self) -> &str {
        use std::ops::Deref;
        self.private_key_identifier.deref()
    }
    /// <p>The <code>keyArn</code> of the certificate that signed the client's <code>PublicKeyCertificate</code>.</p>
    pub fn certificate_authority_public_key_identifier(&self) -> &str {
        use std::ops::Deref;
        self.certificate_authority_public_key_identifier.deref()
    }
    /// <p>The client's public key certificate in PEM format (base64 encoded) to use for ECDH key derivation.</p>
    pub fn public_key_certificate(&self) -> &str {
        use std::ops::Deref;
        self.public_key_certificate.deref()
    }
    /// <p>The key algorithm of the derived ECDH key.</p>
    pub fn derive_key_algorithm(&self) -> &crate::types::SymmetricKeyAlgorithm {
        &self.derive_key_algorithm
    }
    /// <p>The key derivation function to use for deriving a key using ECDH.</p>
    pub fn key_derivation_function(&self) -> &crate::types::KeyDerivationFunction {
        &self.key_derivation_function
    }
    /// <p>The hash type to use for deriving a key using ECDH.</p>
    pub fn key_derivation_hash_algorithm(&self) -> &crate::types::KeyDerivationHashAlgorithm {
        &self.key_derivation_hash_algorithm
    }
    /// <p>The shared information used when deriving a key using ECDH.</p>
    pub fn derivation_data(&self) -> ::std::option::Option<&crate::types::DiffieHellmanDerivationData> {
        self.derivation_data.as_ref()
    }
    /// <p>The WrappedKeyBlock containing the transaction key wrapped using an ECDH dervied key.</p>
    pub fn wrapped_key_block(&self) -> &str {
        use std::ops::Deref;
        self.wrapped_key_block.deref()
    }
}
impl ::std::fmt::Debug for IncomingDiffieHellmanTr31KeyBlock {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let mut formatter = f.debug_struct("IncomingDiffieHellmanTr31KeyBlock");
        formatter.field("private_key_identifier", &self.private_key_identifier);
        formatter.field(
            "certificate_authority_public_key_identifier",
            &self.certificate_authority_public_key_identifier,
        );
        formatter.field("public_key_certificate", &self.public_key_certificate);
        formatter.field("derive_key_algorithm", &self.derive_key_algorithm);
        formatter.field("key_derivation_function", &self.key_derivation_function);
        formatter.field("key_derivation_hash_algorithm", &self.key_derivation_hash_algorithm);
        formatter.field("derivation_data", &self.derivation_data);
        formatter.field("wrapped_key_block", &"*** Sensitive Data Redacted ***");
        formatter.finish()
    }
}
impl IncomingDiffieHellmanTr31KeyBlock {
    /// Creates a new builder-style object to manufacture [`IncomingDiffieHellmanTr31KeyBlock`](crate::types::IncomingDiffieHellmanTr31KeyBlock).
    pub fn builder() -> crate::types::builders::IncomingDiffieHellmanTr31KeyBlockBuilder {
        crate::types::builders::IncomingDiffieHellmanTr31KeyBlockBuilder::default()
    }
}

/// A builder for [`IncomingDiffieHellmanTr31KeyBlock`](crate::types::IncomingDiffieHellmanTr31KeyBlock).
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::default::Default)]
#[non_exhaustive]
pub struct IncomingDiffieHellmanTr31KeyBlockBuilder {
    pub(crate) private_key_identifier: ::std::option::Option<::std::string::String>,
    pub(crate) certificate_authority_public_key_identifier: ::std::option::Option<::std::string::String>,
    pub(crate) public_key_certificate: ::std::option::Option<::std::string::String>,
    pub(crate) derive_key_algorithm: ::std::option::Option<crate::types::SymmetricKeyAlgorithm>,
    pub(crate) key_derivation_function: ::std::option::Option<crate::types::KeyDerivationFunction>,
    pub(crate) key_derivation_hash_algorithm: ::std::option::Option<crate::types::KeyDerivationHashAlgorithm>,
    pub(crate) derivation_data: ::std::option::Option<crate::types::DiffieHellmanDerivationData>,
    pub(crate) wrapped_key_block: ::std::option::Option<::std::string::String>,
}
impl IncomingDiffieHellmanTr31KeyBlockBuilder {
    /// <p>The <code>keyARN</code> of the asymmetric ECC key pair.</p>
    /// This field is required.
    pub fn private_key_identifier(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.private_key_identifier = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The <code>keyARN</code> of the asymmetric ECC key pair.</p>
    pub fn set_private_key_identifier(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.private_key_identifier = input;
        self
    }
    /// <p>The <code>keyARN</code> of the asymmetric ECC key pair.</p>
    pub fn get_private_key_identifier(&self) -> &::std::option::Option<::std::string::String> {
        &self.private_key_identifier
    }
    /// <p>The <code>keyArn</code> of the certificate that signed the client's <code>PublicKeyCertificate</code>.</p>
    /// This field is required.
    pub fn certificate_authority_public_key_identifier(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.certificate_authority_public_key_identifier = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The <code>keyArn</code> of the certificate that signed the client's <code>PublicKeyCertificate</code>.</p>
    pub fn set_certificate_authority_public_key_identifier(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.certificate_authority_public_key_identifier = input;
        self
    }
    /// <p>The <code>keyArn</code> of the certificate that signed the client's <code>PublicKeyCertificate</code>.</p>
    pub fn get_certificate_authority_public_key_identifier(&self) -> &::std::option::Option<::std::string::String> {
        &self.certificate_authority_public_key_identifier
    }
    /// <p>The client's public key certificate in PEM format (base64 encoded) to use for ECDH key derivation.</p>
    /// This field is required.
    pub fn public_key_certificate(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.public_key_certificate = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The client's public key certificate in PEM format (base64 encoded) to use for ECDH key derivation.</p>
    pub fn set_public_key_certificate(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.public_key_certificate = input;
        self
    }
    /// <p>The client's public key certificate in PEM format (base64 encoded) to use for ECDH key derivation.</p>
    pub fn get_public_key_certificate(&self) -> &::std::option::Option<::std::string::String> {
        &self.public_key_certificate
    }
    /// <p>The key algorithm of the derived ECDH key.</p>
    /// This field is required.
    pub fn derive_key_algorithm(mut self, input: crate::types::SymmetricKeyAlgorithm) -> Self {
        self.derive_key_algorithm = ::std::option::Option::Some(input);
        self
    }
    /// <p>The key algorithm of the derived ECDH key.</p>
    pub fn set_derive_key_algorithm(mut self, input: ::std::option::Option<crate::types::SymmetricKeyAlgorithm>) -> Self {
        self.derive_key_algorithm = input;
        self
    }
    /// <p>The key algorithm of the derived ECDH key.</p>
    pub fn get_derive_key_algorithm(&self) -> &::std::option::Option<crate::types::SymmetricKeyAlgorithm> {
        &self.derive_key_algorithm
    }
    /// <p>The key derivation function to use for deriving a key using ECDH.</p>
    /// This field is required.
    pub fn key_derivation_function(mut self, input: crate::types::KeyDerivationFunction) -> Self {
        self.key_derivation_function = ::std::option::Option::Some(input);
        self
    }
    /// <p>The key derivation function to use for deriving a key using ECDH.</p>
    pub fn set_key_derivation_function(mut self, input: ::std::option::Option<crate::types::KeyDerivationFunction>) -> Self {
        self.key_derivation_function = input;
        self
    }
    /// <p>The key derivation function to use for deriving a key using ECDH.</p>
    pub fn get_key_derivation_function(&self) -> &::std::option::Option<crate::types::KeyDerivationFunction> {
        &self.key_derivation_function
    }
    /// <p>The hash type to use for deriving a key using ECDH.</p>
    /// This field is required.
    pub fn key_derivation_hash_algorithm(mut self, input: crate::types::KeyDerivationHashAlgorithm) -> Self {
        self.key_derivation_hash_algorithm = ::std::option::Option::Some(input);
        self
    }
    /// <p>The hash type to use for deriving a key using ECDH.</p>
    pub fn set_key_derivation_hash_algorithm(mut self, input: ::std::option::Option<crate::types::KeyDerivationHashAlgorithm>) -> Self {
        self.key_derivation_hash_algorithm = input;
        self
    }
    /// <p>The hash type to use for deriving a key using ECDH.</p>
    pub fn get_key_derivation_hash_algorithm(&self) -> &::std::option::Option<crate::types::KeyDerivationHashAlgorithm> {
        &self.key_derivation_hash_algorithm
    }
    /// <p>The shared information used when deriving a key using ECDH.</p>
    /// This field is required.
    pub fn derivation_data(mut self, input: crate::types::DiffieHellmanDerivationData) -> Self {
        self.derivation_data = ::std::option::Option::Some(input);
        self
    }
    /// <p>The shared information used when deriving a key using ECDH.</p>
    pub fn set_derivation_data(mut self, input: ::std::option::Option<crate::types::DiffieHellmanDerivationData>) -> Self {
        self.derivation_data = input;
        self
    }
    /// <p>The shared information used when deriving a key using ECDH.</p>
    pub fn get_derivation_data(&self) -> &::std::option::Option<crate::types::DiffieHellmanDerivationData> {
        &self.derivation_data
    }
    /// <p>The WrappedKeyBlock containing the transaction key wrapped using an ECDH dervied key.</p>
    /// This field is required.
    pub fn wrapped_key_block(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.wrapped_key_block = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The WrappedKeyBlock containing the transaction key wrapped using an ECDH dervied key.</p>
    pub fn set_wrapped_key_block(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.wrapped_key_block = input;
        self
    }
    /// <p>The WrappedKeyBlock containing the transaction key wrapped using an ECDH dervied key.</p>
    pub fn get_wrapped_key_block(&self) -> &::std::option::Option<::std::string::String> {
        &self.wrapped_key_block
    }
    /// Consumes the builder and constructs a [`IncomingDiffieHellmanTr31KeyBlock`](crate::types::IncomingDiffieHellmanTr31KeyBlock).
    /// This method will fail if any of the following fields are not set:
    /// - [`private_key_identifier`](crate::types::builders::IncomingDiffieHellmanTr31KeyBlockBuilder::private_key_identifier)
    /// - [`certificate_authority_public_key_identifier`](crate::types::builders::IncomingDiffieHellmanTr31KeyBlockBuilder::certificate_authority_public_key_identifier)
    /// - [`public_key_certificate`](crate::types::builders::IncomingDiffieHellmanTr31KeyBlockBuilder::public_key_certificate)
    /// - [`derive_key_algorithm`](crate::types::builders::IncomingDiffieHellmanTr31KeyBlockBuilder::derive_key_algorithm)
    /// - [`key_derivation_function`](crate::types::builders::IncomingDiffieHellmanTr31KeyBlockBuilder::key_derivation_function)
    /// - [`key_derivation_hash_algorithm`](crate::types::builders::IncomingDiffieHellmanTr31KeyBlockBuilder::key_derivation_hash_algorithm)
    /// - [`wrapped_key_block`](crate::types::builders::IncomingDiffieHellmanTr31KeyBlockBuilder::wrapped_key_block)
    pub fn build(self) -> ::std::result::Result<crate::types::IncomingDiffieHellmanTr31KeyBlock, ::aws_smithy_types::error::operation::BuildError> {
        ::std::result::Result::Ok(
            crate::types::IncomingDiffieHellmanTr31KeyBlock {
                private_key_identifier: self.private_key_identifier
                    .ok_or_else(||
                        ::aws_smithy_types::error::operation::BuildError::missing_field("private_key_identifier", "private_key_identifier was not specified but it is required when building IncomingDiffieHellmanTr31KeyBlock")
                    )?
                ,
                certificate_authority_public_key_identifier: self.certificate_authority_public_key_identifier
                    .ok_or_else(||
                        ::aws_smithy_types::error::operation::BuildError::missing_field("certificate_authority_public_key_identifier", "certificate_authority_public_key_identifier was not specified but it is required when building IncomingDiffieHellmanTr31KeyBlock")
                    )?
                ,
                public_key_certificate: self.public_key_certificate
                    .ok_or_else(||
                        ::aws_smithy_types::error::operation::BuildError::missing_field("public_key_certificate", "public_key_certificate was not specified but it is required when building IncomingDiffieHellmanTr31KeyBlock")
                    )?
                ,
                derive_key_algorithm: self.derive_key_algorithm
                    .ok_or_else(||
                        ::aws_smithy_types::error::operation::BuildError::missing_field("derive_key_algorithm", "derive_key_algorithm was not specified but it is required when building IncomingDiffieHellmanTr31KeyBlock")
                    )?
                ,
                key_derivation_function: self.key_derivation_function
                    .ok_or_else(||
                        ::aws_smithy_types::error::operation::BuildError::missing_field("key_derivation_function", "key_derivation_function was not specified but it is required when building IncomingDiffieHellmanTr31KeyBlock")
                    )?
                ,
                key_derivation_hash_algorithm: self.key_derivation_hash_algorithm
                    .ok_or_else(||
                        ::aws_smithy_types::error::operation::BuildError::missing_field("key_derivation_hash_algorithm", "key_derivation_hash_algorithm was not specified but it is required when building IncomingDiffieHellmanTr31KeyBlock")
                    )?
                ,
                derivation_data: self.derivation_data
                ,
                wrapped_key_block: self.wrapped_key_block
                    .ok_or_else(||
                        ::aws_smithy_types::error::operation::BuildError::missing_field("wrapped_key_block", "wrapped_key_block was not specified but it is required when building IncomingDiffieHellmanTr31KeyBlock")
                    )?
                ,
            }
        )
    }
}
impl ::std::fmt::Debug for IncomingDiffieHellmanTr31KeyBlockBuilder {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let mut formatter = f.debug_struct("IncomingDiffieHellmanTr31KeyBlockBuilder");
        formatter.field("private_key_identifier", &self.private_key_identifier);
        formatter.field(
            "certificate_authority_public_key_identifier",
            &self.certificate_authority_public_key_identifier,
        );
        formatter.field("public_key_certificate", &self.public_key_certificate);
        formatter.field("derive_key_algorithm", &self.derive_key_algorithm);
        formatter.field("key_derivation_function", &self.key_derivation_function);
        formatter.field("key_derivation_hash_algorithm", &self.key_derivation_hash_algorithm);
        formatter.field("derivation_data", &self.derivation_data);
        formatter.field("wrapped_key_block", &"*** Sensitive Data Redacted ***");
        formatter.finish()
    }
}
