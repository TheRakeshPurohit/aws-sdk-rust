// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.

/// <p>A container for various mutation operations that can be applied to an Automated Reasoning policy, including adding, updating, and deleting policy elements.</p>
#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::fmt::Debug)]
pub enum AutomatedReasoningPolicyMutation {
    /// <p>A mutation to add a new rule to the policy.</p>
    AddRule(crate::types::AutomatedReasoningPolicyAddRuleMutation),
    /// <p>A mutation to add a new custom type to the policy.</p>
    AddType(crate::types::AutomatedReasoningPolicyAddTypeMutation),
    /// <p>A mutation to add a new variable to the policy.</p>
    AddVariable(crate::types::AutomatedReasoningPolicyAddVariableMutation),
    /// <p>A mutation to remove a rule from the policy.</p>
    DeleteRule(crate::types::AutomatedReasoningPolicyDeleteRuleMutation),
    /// <p>A mutation to remove a custom type from the policy.</p>
    DeleteType(crate::types::AutomatedReasoningPolicyDeleteTypeMutation),
    /// <p>A mutation to remove a variable from the policy.</p>
    DeleteVariable(crate::types::AutomatedReasoningPolicyDeleteVariableMutation),
    /// <p>A mutation to modify an existing rule in the policy.</p>
    UpdateRule(crate::types::AutomatedReasoningPolicyUpdateRuleMutation),
    /// <p>A mutation to modify an existing custom type in the policy.</p>
    UpdateType(crate::types::AutomatedReasoningPolicyUpdateTypeMutation),
    /// <p>A mutation to modify an existing variable in the policy.</p>
    UpdateVariable(crate::types::AutomatedReasoningPolicyUpdateVariableMutation),
    /// The `Unknown` variant represents cases where new union variant was received. Consider upgrading the SDK to the latest available version.
    /// An unknown enum variant
    ///
    /// _Note: If you encounter this error, consider upgrading your SDK to the latest version._
    /// The `Unknown` variant represents cases where the server sent a value that wasn't recognized
    /// by the client. This can happen when the server adds new functionality, but the client has not been updated.
    /// To investigate this, consider turning on debug logging to print the raw HTTP response.
    #[non_exhaustive]
    Unknown,
}
impl AutomatedReasoningPolicyMutation {
    /// Tries to convert the enum instance into [`AddRule`](crate::types::AutomatedReasoningPolicyMutation::AddRule), extracting the inner [`AutomatedReasoningPolicyAddRuleMutation`](crate::types::AutomatedReasoningPolicyAddRuleMutation).
    /// Returns `Err(&Self)` if it can't be converted.
    pub fn as_add_rule(&self) -> ::std::result::Result<&crate::types::AutomatedReasoningPolicyAddRuleMutation, &Self> {
        if let AutomatedReasoningPolicyMutation::AddRule(val) = &self {
            ::std::result::Result::Ok(val)
        } else {
            ::std::result::Result::Err(self)
        }
    }
    /// Returns true if this is a [`AddRule`](crate::types::AutomatedReasoningPolicyMutation::AddRule).
    pub fn is_add_rule(&self) -> bool {
        self.as_add_rule().is_ok()
    }
    /// Tries to convert the enum instance into [`AddType`](crate::types::AutomatedReasoningPolicyMutation::AddType), extracting the inner [`AutomatedReasoningPolicyAddTypeMutation`](crate::types::AutomatedReasoningPolicyAddTypeMutation).
    /// Returns `Err(&Self)` if it can't be converted.
    pub fn as_add_type(&self) -> ::std::result::Result<&crate::types::AutomatedReasoningPolicyAddTypeMutation, &Self> {
        if let AutomatedReasoningPolicyMutation::AddType(val) = &self {
            ::std::result::Result::Ok(val)
        } else {
            ::std::result::Result::Err(self)
        }
    }
    /// Returns true if this is a [`AddType`](crate::types::AutomatedReasoningPolicyMutation::AddType).
    pub fn is_add_type(&self) -> bool {
        self.as_add_type().is_ok()
    }
    /// Tries to convert the enum instance into [`AddVariable`](crate::types::AutomatedReasoningPolicyMutation::AddVariable), extracting the inner [`AutomatedReasoningPolicyAddVariableMutation`](crate::types::AutomatedReasoningPolicyAddVariableMutation).
    /// Returns `Err(&Self)` if it can't be converted.
    pub fn as_add_variable(&self) -> ::std::result::Result<&crate::types::AutomatedReasoningPolicyAddVariableMutation, &Self> {
        if let AutomatedReasoningPolicyMutation::AddVariable(val) = &self {
            ::std::result::Result::Ok(val)
        } else {
            ::std::result::Result::Err(self)
        }
    }
    /// Returns true if this is a [`AddVariable`](crate::types::AutomatedReasoningPolicyMutation::AddVariable).
    pub fn is_add_variable(&self) -> bool {
        self.as_add_variable().is_ok()
    }
    /// Tries to convert the enum instance into [`DeleteRule`](crate::types::AutomatedReasoningPolicyMutation::DeleteRule), extracting the inner [`AutomatedReasoningPolicyDeleteRuleMutation`](crate::types::AutomatedReasoningPolicyDeleteRuleMutation).
    /// Returns `Err(&Self)` if it can't be converted.
    pub fn as_delete_rule(&self) -> ::std::result::Result<&crate::types::AutomatedReasoningPolicyDeleteRuleMutation, &Self> {
        if let AutomatedReasoningPolicyMutation::DeleteRule(val) = &self {
            ::std::result::Result::Ok(val)
        } else {
            ::std::result::Result::Err(self)
        }
    }
    /// Returns true if this is a [`DeleteRule`](crate::types::AutomatedReasoningPolicyMutation::DeleteRule).
    pub fn is_delete_rule(&self) -> bool {
        self.as_delete_rule().is_ok()
    }
    /// Tries to convert the enum instance into [`DeleteType`](crate::types::AutomatedReasoningPolicyMutation::DeleteType), extracting the inner [`AutomatedReasoningPolicyDeleteTypeMutation`](crate::types::AutomatedReasoningPolicyDeleteTypeMutation).
    /// Returns `Err(&Self)` if it can't be converted.
    pub fn as_delete_type(&self) -> ::std::result::Result<&crate::types::AutomatedReasoningPolicyDeleteTypeMutation, &Self> {
        if let AutomatedReasoningPolicyMutation::DeleteType(val) = &self {
            ::std::result::Result::Ok(val)
        } else {
            ::std::result::Result::Err(self)
        }
    }
    /// Returns true if this is a [`DeleteType`](crate::types::AutomatedReasoningPolicyMutation::DeleteType).
    pub fn is_delete_type(&self) -> bool {
        self.as_delete_type().is_ok()
    }
    /// Tries to convert the enum instance into [`DeleteVariable`](crate::types::AutomatedReasoningPolicyMutation::DeleteVariable), extracting the inner [`AutomatedReasoningPolicyDeleteVariableMutation`](crate::types::AutomatedReasoningPolicyDeleteVariableMutation).
    /// Returns `Err(&Self)` if it can't be converted.
    pub fn as_delete_variable(&self) -> ::std::result::Result<&crate::types::AutomatedReasoningPolicyDeleteVariableMutation, &Self> {
        if let AutomatedReasoningPolicyMutation::DeleteVariable(val) = &self {
            ::std::result::Result::Ok(val)
        } else {
            ::std::result::Result::Err(self)
        }
    }
    /// Returns true if this is a [`DeleteVariable`](crate::types::AutomatedReasoningPolicyMutation::DeleteVariable).
    pub fn is_delete_variable(&self) -> bool {
        self.as_delete_variable().is_ok()
    }
    /// Tries to convert the enum instance into [`UpdateRule`](crate::types::AutomatedReasoningPolicyMutation::UpdateRule), extracting the inner [`AutomatedReasoningPolicyUpdateRuleMutation`](crate::types::AutomatedReasoningPolicyUpdateRuleMutation).
    /// Returns `Err(&Self)` if it can't be converted.
    pub fn as_update_rule(&self) -> ::std::result::Result<&crate::types::AutomatedReasoningPolicyUpdateRuleMutation, &Self> {
        if let AutomatedReasoningPolicyMutation::UpdateRule(val) = &self {
            ::std::result::Result::Ok(val)
        } else {
            ::std::result::Result::Err(self)
        }
    }
    /// Returns true if this is a [`UpdateRule`](crate::types::AutomatedReasoningPolicyMutation::UpdateRule).
    pub fn is_update_rule(&self) -> bool {
        self.as_update_rule().is_ok()
    }
    /// Tries to convert the enum instance into [`UpdateType`](crate::types::AutomatedReasoningPolicyMutation::UpdateType), extracting the inner [`AutomatedReasoningPolicyUpdateTypeMutation`](crate::types::AutomatedReasoningPolicyUpdateTypeMutation).
    /// Returns `Err(&Self)` if it can't be converted.
    pub fn as_update_type(&self) -> ::std::result::Result<&crate::types::AutomatedReasoningPolicyUpdateTypeMutation, &Self> {
        if let AutomatedReasoningPolicyMutation::UpdateType(val) = &self {
            ::std::result::Result::Ok(val)
        } else {
            ::std::result::Result::Err(self)
        }
    }
    /// Returns true if this is a [`UpdateType`](crate::types::AutomatedReasoningPolicyMutation::UpdateType).
    pub fn is_update_type(&self) -> bool {
        self.as_update_type().is_ok()
    }
    /// Tries to convert the enum instance into [`UpdateVariable`](crate::types::AutomatedReasoningPolicyMutation::UpdateVariable), extracting the inner [`AutomatedReasoningPolicyUpdateVariableMutation`](crate::types::AutomatedReasoningPolicyUpdateVariableMutation).
    /// Returns `Err(&Self)` if it can't be converted.
    pub fn as_update_variable(&self) -> ::std::result::Result<&crate::types::AutomatedReasoningPolicyUpdateVariableMutation, &Self> {
        if let AutomatedReasoningPolicyMutation::UpdateVariable(val) = &self {
            ::std::result::Result::Ok(val)
        } else {
            ::std::result::Result::Err(self)
        }
    }
    /// Returns true if this is a [`UpdateVariable`](crate::types::AutomatedReasoningPolicyMutation::UpdateVariable).
    pub fn is_update_variable(&self) -> bool {
        self.as_update_variable().is_ok()
    }
    /// Returns true if the enum instance is the `Unknown` variant.
    pub fn is_unknown(&self) -> bool {
        matches!(self, Self::Unknown)
    }
}
