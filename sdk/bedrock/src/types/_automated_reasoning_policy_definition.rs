// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.

/// <p>Contains the formal logic rules, variables, and custom variable types that define an Automated Reasoning policy. The policy definition specifies the constraints used to validate foundation model responses for accuracy and logical consistency.</p>
#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::fmt::Debug)]
pub struct AutomatedReasoningPolicyDefinition {
    /// <p>The version of the policy definition format.</p>
    pub version: ::std::string::String,
    /// <p>The custom user-defined vairable types used in the policy. Types are enum-based variable types that provide additional context beyond the predefined variable types.</p>
    pub types: ::std::option::Option<::std::vec::Vec<crate::types::AutomatedReasoningPolicyDefinitionType>>,
    /// <p>The formal logic rules extracted from the source document. Rules define the logical constraints that determine whether model responses are valid, invalid, or satisfiable.</p>
    pub rules: ::std::option::Option<::std::vec::Vec<crate::types::AutomatedReasoningPolicyDefinitionRule>>,
    /// <p>The variables that represent concepts in the policy. Variables can have values assigned when translating natural language into formal logic. Their descriptions are crucial for accurate translation.</p>
    pub variables: ::std::option::Option<::std::vec::Vec<crate::types::AutomatedReasoningPolicyDefinitionVariable>>,
}
impl AutomatedReasoningPolicyDefinition {
    /// <p>The version of the policy definition format.</p>
    pub fn version(&self) -> &str {
        use std::ops::Deref;
        self.version.deref()
    }
    /// <p>The custom user-defined vairable types used in the policy. Types are enum-based variable types that provide additional context beyond the predefined variable types.</p>
    ///
    /// If no value was sent for this field, a default will be set. If you want to determine if no value was sent, use `.types.is_none()`.
    pub fn types(&self) -> &[crate::types::AutomatedReasoningPolicyDefinitionType] {
        self.types.as_deref().unwrap_or_default()
    }
    /// <p>The formal logic rules extracted from the source document. Rules define the logical constraints that determine whether model responses are valid, invalid, or satisfiable.</p>
    ///
    /// If no value was sent for this field, a default will be set. If you want to determine if no value was sent, use `.rules.is_none()`.
    pub fn rules(&self) -> &[crate::types::AutomatedReasoningPolicyDefinitionRule] {
        self.rules.as_deref().unwrap_or_default()
    }
    /// <p>The variables that represent concepts in the policy. Variables can have values assigned when translating natural language into formal logic. Their descriptions are crucial for accurate translation.</p>
    ///
    /// If no value was sent for this field, a default will be set. If you want to determine if no value was sent, use `.variables.is_none()`.
    pub fn variables(&self) -> &[crate::types::AutomatedReasoningPolicyDefinitionVariable] {
        self.variables.as_deref().unwrap_or_default()
    }
}
impl AutomatedReasoningPolicyDefinition {
    /// Creates a new builder-style object to manufacture [`AutomatedReasoningPolicyDefinition`](crate::types::AutomatedReasoningPolicyDefinition).
    pub fn builder() -> crate::types::builders::AutomatedReasoningPolicyDefinitionBuilder {
        crate::types::builders::AutomatedReasoningPolicyDefinitionBuilder::default()
    }
}

/// A builder for [`AutomatedReasoningPolicyDefinition`](crate::types::AutomatedReasoningPolicyDefinition).
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::default::Default, ::std::fmt::Debug)]
#[non_exhaustive]
pub struct AutomatedReasoningPolicyDefinitionBuilder {
    pub(crate) version: ::std::option::Option<::std::string::String>,
    pub(crate) types: ::std::option::Option<::std::vec::Vec<crate::types::AutomatedReasoningPolicyDefinitionType>>,
    pub(crate) rules: ::std::option::Option<::std::vec::Vec<crate::types::AutomatedReasoningPolicyDefinitionRule>>,
    pub(crate) variables: ::std::option::Option<::std::vec::Vec<crate::types::AutomatedReasoningPolicyDefinitionVariable>>,
}
impl AutomatedReasoningPolicyDefinitionBuilder {
    /// <p>The version of the policy definition format.</p>
    pub fn version(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.version = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The version of the policy definition format.</p>
    pub fn set_version(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.version = input;
        self
    }
    /// <p>The version of the policy definition format.</p>
    pub fn get_version(&self) -> &::std::option::Option<::std::string::String> {
        &self.version
    }
    /// Appends an item to `types`.
    ///
    /// To override the contents of this collection use [`set_types`](Self::set_types).
    ///
    /// <p>The custom user-defined vairable types used in the policy. Types are enum-based variable types that provide additional context beyond the predefined variable types.</p>
    pub fn types(mut self, input: crate::types::AutomatedReasoningPolicyDefinitionType) -> Self {
        let mut v = self.types.unwrap_or_default();
        v.push(input);
        self.types = ::std::option::Option::Some(v);
        self
    }
    /// <p>The custom user-defined vairable types used in the policy. Types are enum-based variable types that provide additional context beyond the predefined variable types.</p>
    pub fn set_types(mut self, input: ::std::option::Option<::std::vec::Vec<crate::types::AutomatedReasoningPolicyDefinitionType>>) -> Self {
        self.types = input;
        self
    }
    /// <p>The custom user-defined vairable types used in the policy. Types are enum-based variable types that provide additional context beyond the predefined variable types.</p>
    pub fn get_types(&self) -> &::std::option::Option<::std::vec::Vec<crate::types::AutomatedReasoningPolicyDefinitionType>> {
        &self.types
    }
    /// Appends an item to `rules`.
    ///
    /// To override the contents of this collection use [`set_rules`](Self::set_rules).
    ///
    /// <p>The formal logic rules extracted from the source document. Rules define the logical constraints that determine whether model responses are valid, invalid, or satisfiable.</p>
    pub fn rules(mut self, input: crate::types::AutomatedReasoningPolicyDefinitionRule) -> Self {
        let mut v = self.rules.unwrap_or_default();
        v.push(input);
        self.rules = ::std::option::Option::Some(v);
        self
    }
    /// <p>The formal logic rules extracted from the source document. Rules define the logical constraints that determine whether model responses are valid, invalid, or satisfiable.</p>
    pub fn set_rules(mut self, input: ::std::option::Option<::std::vec::Vec<crate::types::AutomatedReasoningPolicyDefinitionRule>>) -> Self {
        self.rules = input;
        self
    }
    /// <p>The formal logic rules extracted from the source document. Rules define the logical constraints that determine whether model responses are valid, invalid, or satisfiable.</p>
    pub fn get_rules(&self) -> &::std::option::Option<::std::vec::Vec<crate::types::AutomatedReasoningPolicyDefinitionRule>> {
        &self.rules
    }
    /// Appends an item to `variables`.
    ///
    /// To override the contents of this collection use [`set_variables`](Self::set_variables).
    ///
    /// <p>The variables that represent concepts in the policy. Variables can have values assigned when translating natural language into formal logic. Their descriptions are crucial for accurate translation.</p>
    pub fn variables(mut self, input: crate::types::AutomatedReasoningPolicyDefinitionVariable) -> Self {
        let mut v = self.variables.unwrap_or_default();
        v.push(input);
        self.variables = ::std::option::Option::Some(v);
        self
    }
    /// <p>The variables that represent concepts in the policy. Variables can have values assigned when translating natural language into formal logic. Their descriptions are crucial for accurate translation.</p>
    pub fn set_variables(mut self, input: ::std::option::Option<::std::vec::Vec<crate::types::AutomatedReasoningPolicyDefinitionVariable>>) -> Self {
        self.variables = input;
        self
    }
    /// <p>The variables that represent concepts in the policy. Variables can have values assigned when translating natural language into formal logic. Their descriptions are crucial for accurate translation.</p>
    pub fn get_variables(&self) -> &::std::option::Option<::std::vec::Vec<crate::types::AutomatedReasoningPolicyDefinitionVariable>> {
        &self.variables
    }
    /// Consumes the builder and constructs a [`AutomatedReasoningPolicyDefinition`](crate::types::AutomatedReasoningPolicyDefinition).
    pub fn build(self) -> crate::types::AutomatedReasoningPolicyDefinition {
        crate::types::AutomatedReasoningPolicyDefinition {
            version: self.version.unwrap_or_else(|| "1".to_owned()),
            types: self.types,
            rules: self.rules,
            variables: self.variables,
        }
    }
}
