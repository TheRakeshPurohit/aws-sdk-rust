// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.

/// <p>Contains the various operations that can be performed on an Automated Reasoning policy, including adding, updating, and deleting rules, variables, and types.</p>
#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::fmt::Debug)]
pub enum AutomatedReasoningPolicyAnnotation {
    /// <p>An operation to add a new logical rule to the policy using formal mathematical expressions.</p>
    AddRule(crate::types::AutomatedReasoningPolicyAddRuleAnnotation),
    /// <p>An operation to add a new rule by converting natural language descriptions into formal logical expressions.</p>
    AddRuleFromNaturalLanguage(crate::types::AutomatedReasoningPolicyAddRuleFromNaturalLanguageAnnotation),
    /// <p>An operation to add a new custom type to the policy, defining a set of possible values for policy variables.</p>
    AddType(crate::types::AutomatedReasoningPolicyAddTypeAnnotation),
    /// <p>An operation to add a new variable to the policy, which can be used in rule expressions to represent dynamic values.</p>
    AddVariable(crate::types::AutomatedReasoningPolicyAddVariableAnnotation),
    /// <p>An operation to remove a rule from the policy.</p>
    DeleteRule(crate::types::AutomatedReasoningPolicyDeleteRuleAnnotation),
    /// <p>An operation to remove a custom type from the policy. The type must not be referenced by any variables or rules.</p>
    DeleteType(crate::types::AutomatedReasoningPolicyDeleteTypeAnnotation),
    /// <p>An operation to remove a variable from the policy. The variable must not be referenced by any rules.</p>
    DeleteVariable(crate::types::AutomatedReasoningPolicyDeleteVariableAnnotation),
    /// <p>An operation to process and incorporate new content into the policy, extracting additional rules and concepts.</p>
    IngestContent(crate::types::AutomatedReasoningPolicyIngestContentAnnotation),
    /// <p>An operation to update the policy based on feedback about how specific rules performed during testing or validation.</p>
    UpdateFromRulesFeedback(crate::types::AutomatedReasoningPolicyUpdateFromRuleFeedbackAnnotation),
    /// <p>An operation to update the policy based on feedback about how it performed on specific test scenarios.</p>
    UpdateFromScenarioFeedback(crate::types::AutomatedReasoningPolicyUpdateFromScenarioFeedbackAnnotation),
    /// <p>An operation to modify an existing rule in the policy, such as changing its logical expression or conditions.</p>
    UpdateRule(crate::types::AutomatedReasoningPolicyUpdateRuleAnnotation),
    /// <p>An operation to modify an existing custom type in the policy, such as changing its name, description, or allowed values.</p>
    UpdateType(crate::types::AutomatedReasoningPolicyUpdateTypeAnnotation),
    /// <p>An operation to modify an existing variable in the policy, such as changing its name, type, or description.</p>
    UpdateVariable(crate::types::AutomatedReasoningPolicyUpdateVariableAnnotation),
    /// The `Unknown` variant represents cases where new union variant was received. Consider upgrading the SDK to the latest available version.
    /// An unknown enum variant
    ///
    /// _Note: If you encounter this error, consider upgrading your SDK to the latest version._
    /// The `Unknown` variant represents cases where the server sent a value that wasn't recognized
    /// by the client. This can happen when the server adds new functionality, but the client has not been updated.
    /// To investigate this, consider turning on debug logging to print the raw HTTP response.
    #[non_exhaustive]
    Unknown,
}
impl AutomatedReasoningPolicyAnnotation {
    /// Tries to convert the enum instance into [`AddRule`](crate::types::AutomatedReasoningPolicyAnnotation::AddRule), extracting the inner [`AutomatedReasoningPolicyAddRuleAnnotation`](crate::types::AutomatedReasoningPolicyAddRuleAnnotation).
    /// Returns `Err(&Self)` if it can't be converted.
    pub fn as_add_rule(&self) -> ::std::result::Result<&crate::types::AutomatedReasoningPolicyAddRuleAnnotation, &Self> {
        if let AutomatedReasoningPolicyAnnotation::AddRule(val) = &self {
            ::std::result::Result::Ok(val)
        } else {
            ::std::result::Result::Err(self)
        }
    }
    /// Returns true if this is a [`AddRule`](crate::types::AutomatedReasoningPolicyAnnotation::AddRule).
    pub fn is_add_rule(&self) -> bool {
        self.as_add_rule().is_ok()
    }
    /// Tries to convert the enum instance into [`AddRuleFromNaturalLanguage`](crate::types::AutomatedReasoningPolicyAnnotation::AddRuleFromNaturalLanguage), extracting the inner [`AutomatedReasoningPolicyAddRuleFromNaturalLanguageAnnotation`](crate::types::AutomatedReasoningPolicyAddRuleFromNaturalLanguageAnnotation).
    /// Returns `Err(&Self)` if it can't be converted.
    pub fn as_add_rule_from_natural_language(
        &self,
    ) -> ::std::result::Result<&crate::types::AutomatedReasoningPolicyAddRuleFromNaturalLanguageAnnotation, &Self> {
        if let AutomatedReasoningPolicyAnnotation::AddRuleFromNaturalLanguage(val) = &self {
            ::std::result::Result::Ok(val)
        } else {
            ::std::result::Result::Err(self)
        }
    }
    /// Returns true if this is a [`AddRuleFromNaturalLanguage`](crate::types::AutomatedReasoningPolicyAnnotation::AddRuleFromNaturalLanguage).
    pub fn is_add_rule_from_natural_language(&self) -> bool {
        self.as_add_rule_from_natural_language().is_ok()
    }
    /// Tries to convert the enum instance into [`AddType`](crate::types::AutomatedReasoningPolicyAnnotation::AddType), extracting the inner [`AutomatedReasoningPolicyAddTypeAnnotation`](crate::types::AutomatedReasoningPolicyAddTypeAnnotation).
    /// Returns `Err(&Self)` if it can't be converted.
    pub fn as_add_type(&self) -> ::std::result::Result<&crate::types::AutomatedReasoningPolicyAddTypeAnnotation, &Self> {
        if let AutomatedReasoningPolicyAnnotation::AddType(val) = &self {
            ::std::result::Result::Ok(val)
        } else {
            ::std::result::Result::Err(self)
        }
    }
    /// Returns true if this is a [`AddType`](crate::types::AutomatedReasoningPolicyAnnotation::AddType).
    pub fn is_add_type(&self) -> bool {
        self.as_add_type().is_ok()
    }
    /// Tries to convert the enum instance into [`AddVariable`](crate::types::AutomatedReasoningPolicyAnnotation::AddVariable), extracting the inner [`AutomatedReasoningPolicyAddVariableAnnotation`](crate::types::AutomatedReasoningPolicyAddVariableAnnotation).
    /// Returns `Err(&Self)` if it can't be converted.
    pub fn as_add_variable(&self) -> ::std::result::Result<&crate::types::AutomatedReasoningPolicyAddVariableAnnotation, &Self> {
        if let AutomatedReasoningPolicyAnnotation::AddVariable(val) = &self {
            ::std::result::Result::Ok(val)
        } else {
            ::std::result::Result::Err(self)
        }
    }
    /// Returns true if this is a [`AddVariable`](crate::types::AutomatedReasoningPolicyAnnotation::AddVariable).
    pub fn is_add_variable(&self) -> bool {
        self.as_add_variable().is_ok()
    }
    /// Tries to convert the enum instance into [`DeleteRule`](crate::types::AutomatedReasoningPolicyAnnotation::DeleteRule), extracting the inner [`AutomatedReasoningPolicyDeleteRuleAnnotation`](crate::types::AutomatedReasoningPolicyDeleteRuleAnnotation).
    /// Returns `Err(&Self)` if it can't be converted.
    pub fn as_delete_rule(&self) -> ::std::result::Result<&crate::types::AutomatedReasoningPolicyDeleteRuleAnnotation, &Self> {
        if let AutomatedReasoningPolicyAnnotation::DeleteRule(val) = &self {
            ::std::result::Result::Ok(val)
        } else {
            ::std::result::Result::Err(self)
        }
    }
    /// Returns true if this is a [`DeleteRule`](crate::types::AutomatedReasoningPolicyAnnotation::DeleteRule).
    pub fn is_delete_rule(&self) -> bool {
        self.as_delete_rule().is_ok()
    }
    /// Tries to convert the enum instance into [`DeleteType`](crate::types::AutomatedReasoningPolicyAnnotation::DeleteType), extracting the inner [`AutomatedReasoningPolicyDeleteTypeAnnotation`](crate::types::AutomatedReasoningPolicyDeleteTypeAnnotation).
    /// Returns `Err(&Self)` if it can't be converted.
    pub fn as_delete_type(&self) -> ::std::result::Result<&crate::types::AutomatedReasoningPolicyDeleteTypeAnnotation, &Self> {
        if let AutomatedReasoningPolicyAnnotation::DeleteType(val) = &self {
            ::std::result::Result::Ok(val)
        } else {
            ::std::result::Result::Err(self)
        }
    }
    /// Returns true if this is a [`DeleteType`](crate::types::AutomatedReasoningPolicyAnnotation::DeleteType).
    pub fn is_delete_type(&self) -> bool {
        self.as_delete_type().is_ok()
    }
    /// Tries to convert the enum instance into [`DeleteVariable`](crate::types::AutomatedReasoningPolicyAnnotation::DeleteVariable), extracting the inner [`AutomatedReasoningPolicyDeleteVariableAnnotation`](crate::types::AutomatedReasoningPolicyDeleteVariableAnnotation).
    /// Returns `Err(&Self)` if it can't be converted.
    pub fn as_delete_variable(&self) -> ::std::result::Result<&crate::types::AutomatedReasoningPolicyDeleteVariableAnnotation, &Self> {
        if let AutomatedReasoningPolicyAnnotation::DeleteVariable(val) = &self {
            ::std::result::Result::Ok(val)
        } else {
            ::std::result::Result::Err(self)
        }
    }
    /// Returns true if this is a [`DeleteVariable`](crate::types::AutomatedReasoningPolicyAnnotation::DeleteVariable).
    pub fn is_delete_variable(&self) -> bool {
        self.as_delete_variable().is_ok()
    }
    /// Tries to convert the enum instance into [`IngestContent`](crate::types::AutomatedReasoningPolicyAnnotation::IngestContent), extracting the inner [`AutomatedReasoningPolicyIngestContentAnnotation`](crate::types::AutomatedReasoningPolicyIngestContentAnnotation).
    /// Returns `Err(&Self)` if it can't be converted.
    pub fn as_ingest_content(&self) -> ::std::result::Result<&crate::types::AutomatedReasoningPolicyIngestContentAnnotation, &Self> {
        if let AutomatedReasoningPolicyAnnotation::IngestContent(val) = &self {
            ::std::result::Result::Ok(val)
        } else {
            ::std::result::Result::Err(self)
        }
    }
    /// Returns true if this is a [`IngestContent`](crate::types::AutomatedReasoningPolicyAnnotation::IngestContent).
    pub fn is_ingest_content(&self) -> bool {
        self.as_ingest_content().is_ok()
    }
    /// Tries to convert the enum instance into [`UpdateFromRulesFeedback`](crate::types::AutomatedReasoningPolicyAnnotation::UpdateFromRulesFeedback), extracting the inner [`AutomatedReasoningPolicyUpdateFromRuleFeedbackAnnotation`](crate::types::AutomatedReasoningPolicyUpdateFromRuleFeedbackAnnotation).
    /// Returns `Err(&Self)` if it can't be converted.
    pub fn as_update_from_rules_feedback(
        &self,
    ) -> ::std::result::Result<&crate::types::AutomatedReasoningPolicyUpdateFromRuleFeedbackAnnotation, &Self> {
        if let AutomatedReasoningPolicyAnnotation::UpdateFromRulesFeedback(val) = &self {
            ::std::result::Result::Ok(val)
        } else {
            ::std::result::Result::Err(self)
        }
    }
    /// Returns true if this is a [`UpdateFromRulesFeedback`](crate::types::AutomatedReasoningPolicyAnnotation::UpdateFromRulesFeedback).
    pub fn is_update_from_rules_feedback(&self) -> bool {
        self.as_update_from_rules_feedback().is_ok()
    }
    /// Tries to convert the enum instance into [`UpdateFromScenarioFeedback`](crate::types::AutomatedReasoningPolicyAnnotation::UpdateFromScenarioFeedback), extracting the inner [`AutomatedReasoningPolicyUpdateFromScenarioFeedbackAnnotation`](crate::types::AutomatedReasoningPolicyUpdateFromScenarioFeedbackAnnotation).
    /// Returns `Err(&Self)` if it can't be converted.
    pub fn as_update_from_scenario_feedback(
        &self,
    ) -> ::std::result::Result<&crate::types::AutomatedReasoningPolicyUpdateFromScenarioFeedbackAnnotation, &Self> {
        if let AutomatedReasoningPolicyAnnotation::UpdateFromScenarioFeedback(val) = &self {
            ::std::result::Result::Ok(val)
        } else {
            ::std::result::Result::Err(self)
        }
    }
    /// Returns true if this is a [`UpdateFromScenarioFeedback`](crate::types::AutomatedReasoningPolicyAnnotation::UpdateFromScenarioFeedback).
    pub fn is_update_from_scenario_feedback(&self) -> bool {
        self.as_update_from_scenario_feedback().is_ok()
    }
    /// Tries to convert the enum instance into [`UpdateRule`](crate::types::AutomatedReasoningPolicyAnnotation::UpdateRule), extracting the inner [`AutomatedReasoningPolicyUpdateRuleAnnotation`](crate::types::AutomatedReasoningPolicyUpdateRuleAnnotation).
    /// Returns `Err(&Self)` if it can't be converted.
    pub fn as_update_rule(&self) -> ::std::result::Result<&crate::types::AutomatedReasoningPolicyUpdateRuleAnnotation, &Self> {
        if let AutomatedReasoningPolicyAnnotation::UpdateRule(val) = &self {
            ::std::result::Result::Ok(val)
        } else {
            ::std::result::Result::Err(self)
        }
    }
    /// Returns true if this is a [`UpdateRule`](crate::types::AutomatedReasoningPolicyAnnotation::UpdateRule).
    pub fn is_update_rule(&self) -> bool {
        self.as_update_rule().is_ok()
    }
    /// Tries to convert the enum instance into [`UpdateType`](crate::types::AutomatedReasoningPolicyAnnotation::UpdateType), extracting the inner [`AutomatedReasoningPolicyUpdateTypeAnnotation`](crate::types::AutomatedReasoningPolicyUpdateTypeAnnotation).
    /// Returns `Err(&Self)` if it can't be converted.
    pub fn as_update_type(&self) -> ::std::result::Result<&crate::types::AutomatedReasoningPolicyUpdateTypeAnnotation, &Self> {
        if let AutomatedReasoningPolicyAnnotation::UpdateType(val) = &self {
            ::std::result::Result::Ok(val)
        } else {
            ::std::result::Result::Err(self)
        }
    }
    /// Returns true if this is a [`UpdateType`](crate::types::AutomatedReasoningPolicyAnnotation::UpdateType).
    pub fn is_update_type(&self) -> bool {
        self.as_update_type().is_ok()
    }
    /// Tries to convert the enum instance into [`UpdateVariable`](crate::types::AutomatedReasoningPolicyAnnotation::UpdateVariable), extracting the inner [`AutomatedReasoningPolicyUpdateVariableAnnotation`](crate::types::AutomatedReasoningPolicyUpdateVariableAnnotation).
    /// Returns `Err(&Self)` if it can't be converted.
    pub fn as_update_variable(&self) -> ::std::result::Result<&crate::types::AutomatedReasoningPolicyUpdateVariableAnnotation, &Self> {
        if let AutomatedReasoningPolicyAnnotation::UpdateVariable(val) = &self {
            ::std::result::Result::Ok(val)
        } else {
            ::std::result::Result::Err(self)
        }
    }
    /// Returns true if this is a [`UpdateVariable`](crate::types::AutomatedReasoningPolicyAnnotation::UpdateVariable).
    pub fn is_update_variable(&self) -> bool {
        self.as_update_variable().is_ok()
    }
    /// Returns true if the enum instance is the `Unknown` variant.
    pub fn is_unknown(&self) -> bool {
        matches!(self, Self::Unknown)
    }
}
