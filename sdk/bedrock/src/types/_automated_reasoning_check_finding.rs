// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.

/// <p>Represents the result of an Automated Reasoning validation check, indicating whether the content is logically valid, invalid, or falls into other categories based on the policy rules.</p>
#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::fmt::Debug)]
pub enum AutomatedReasoningCheckFinding {
    /// <p>Indicates that Automated Reasoning cannot make a statement about the claims. This can happen if the premises are logically incorrect, or if there is a conflict within the Automated Reasoning policy itself.</p>
    Impossible(crate::types::AutomatedReasoningCheckImpossibleFinding),
    /// <p>Indicates that the claims are false. The claims are not implied by the premises and Automated Reasoning policy. Furthermore, there exist different claims that are consistent with the premises and Automated Reasoning policy.</p>
    Invalid(crate::types::AutomatedReasoningCheckInvalidFinding),
    /// <p>Identifies that some or all of the input prompt wasn't translated into logic. This can happen if the input isn't relevant to the Automated Reasoning policy, or if the policy doesn't have variables to model relevant input.</p>
    NoTranslations(crate::types::AutomatedReasoningCheckNoTranslationsFinding),
    /// <p>Indicates that the claims can be true or false. It depends on what assumptions are made for the claim to be implied from the premises and Automated Reasoning policy rules. In this situation, different assumptions can make input claims false and alternative claims true.</p>
    Satisfiable(crate::types::AutomatedReasoningCheckSatisfiableFinding),
    /// <p>Indicates that the input contains too much information for Automated Reasoning to process within its latency limits.</p>
    TooComplex(crate::types::AutomatedReasoningCheckTooComplexFinding),
    /// <p>Indicates that an ambiguity was detected in the translation, making it unsound to continue with validity checking. Additional context or follow-up questions might be needed to get translation to succeed.</p>
    TranslationAmbiguous(crate::types::AutomatedReasoningCheckTranslationAmbiguousFinding),
    /// <p>Indicates that the claims are true. The claims are implied by the premises and the Automated Reasoning policy. Given the Automated Reasoning policy and premises, it is not possible for these claims to be false.</p>
    Valid(crate::types::AutomatedReasoningCheckValidFinding),
    /// The `Unknown` variant represents cases where new union variant was received. Consider upgrading the SDK to the latest available version.
    /// An unknown enum variant
    ///
    /// _Note: If you encounter this error, consider upgrading your SDK to the latest version._
    /// The `Unknown` variant represents cases where the server sent a value that wasn't recognized
    /// by the client. This can happen when the server adds new functionality, but the client has not been updated.
    /// To investigate this, consider turning on debug logging to print the raw HTTP response.
    #[non_exhaustive]
    Unknown,
}
impl AutomatedReasoningCheckFinding {
    /// Tries to convert the enum instance into [`Impossible`](crate::types::AutomatedReasoningCheckFinding::Impossible), extracting the inner [`AutomatedReasoningCheckImpossibleFinding`](crate::types::AutomatedReasoningCheckImpossibleFinding).
    /// Returns `Err(&Self)` if it can't be converted.
    pub fn as_impossible(&self) -> ::std::result::Result<&crate::types::AutomatedReasoningCheckImpossibleFinding, &Self> {
        if let AutomatedReasoningCheckFinding::Impossible(val) = &self {
            ::std::result::Result::Ok(val)
        } else {
            ::std::result::Result::Err(self)
        }
    }
    /// Returns true if this is a [`Impossible`](crate::types::AutomatedReasoningCheckFinding::Impossible).
    pub fn is_impossible(&self) -> bool {
        self.as_impossible().is_ok()
    }
    /// Tries to convert the enum instance into [`Invalid`](crate::types::AutomatedReasoningCheckFinding::Invalid), extracting the inner [`AutomatedReasoningCheckInvalidFinding`](crate::types::AutomatedReasoningCheckInvalidFinding).
    /// Returns `Err(&Self)` if it can't be converted.
    pub fn as_invalid(&self) -> ::std::result::Result<&crate::types::AutomatedReasoningCheckInvalidFinding, &Self> {
        if let AutomatedReasoningCheckFinding::Invalid(val) = &self {
            ::std::result::Result::Ok(val)
        } else {
            ::std::result::Result::Err(self)
        }
    }
    /// Returns true if this is a [`Invalid`](crate::types::AutomatedReasoningCheckFinding::Invalid).
    pub fn is_invalid(&self) -> bool {
        self.as_invalid().is_ok()
    }
    /// Tries to convert the enum instance into [`NoTranslations`](crate::types::AutomatedReasoningCheckFinding::NoTranslations), extracting the inner [`AutomatedReasoningCheckNoTranslationsFinding`](crate::types::AutomatedReasoningCheckNoTranslationsFinding).
    /// Returns `Err(&Self)` if it can't be converted.
    pub fn as_no_translations(&self) -> ::std::result::Result<&crate::types::AutomatedReasoningCheckNoTranslationsFinding, &Self> {
        if let AutomatedReasoningCheckFinding::NoTranslations(val) = &self {
            ::std::result::Result::Ok(val)
        } else {
            ::std::result::Result::Err(self)
        }
    }
    /// Returns true if this is a [`NoTranslations`](crate::types::AutomatedReasoningCheckFinding::NoTranslations).
    pub fn is_no_translations(&self) -> bool {
        self.as_no_translations().is_ok()
    }
    /// Tries to convert the enum instance into [`Satisfiable`](crate::types::AutomatedReasoningCheckFinding::Satisfiable), extracting the inner [`AutomatedReasoningCheckSatisfiableFinding`](crate::types::AutomatedReasoningCheckSatisfiableFinding).
    /// Returns `Err(&Self)` if it can't be converted.
    pub fn as_satisfiable(&self) -> ::std::result::Result<&crate::types::AutomatedReasoningCheckSatisfiableFinding, &Self> {
        if let AutomatedReasoningCheckFinding::Satisfiable(val) = &self {
            ::std::result::Result::Ok(val)
        } else {
            ::std::result::Result::Err(self)
        }
    }
    /// Returns true if this is a [`Satisfiable`](crate::types::AutomatedReasoningCheckFinding::Satisfiable).
    pub fn is_satisfiable(&self) -> bool {
        self.as_satisfiable().is_ok()
    }
    /// Tries to convert the enum instance into [`TooComplex`](crate::types::AutomatedReasoningCheckFinding::TooComplex), extracting the inner [`AutomatedReasoningCheckTooComplexFinding`](crate::types::AutomatedReasoningCheckTooComplexFinding).
    /// Returns `Err(&Self)` if it can't be converted.
    pub fn as_too_complex(&self) -> ::std::result::Result<&crate::types::AutomatedReasoningCheckTooComplexFinding, &Self> {
        if let AutomatedReasoningCheckFinding::TooComplex(val) = &self {
            ::std::result::Result::Ok(val)
        } else {
            ::std::result::Result::Err(self)
        }
    }
    /// Returns true if this is a [`TooComplex`](crate::types::AutomatedReasoningCheckFinding::TooComplex).
    pub fn is_too_complex(&self) -> bool {
        self.as_too_complex().is_ok()
    }
    /// Tries to convert the enum instance into [`TranslationAmbiguous`](crate::types::AutomatedReasoningCheckFinding::TranslationAmbiguous), extracting the inner [`AutomatedReasoningCheckTranslationAmbiguousFinding`](crate::types::AutomatedReasoningCheckTranslationAmbiguousFinding).
    /// Returns `Err(&Self)` if it can't be converted.
    pub fn as_translation_ambiguous(&self) -> ::std::result::Result<&crate::types::AutomatedReasoningCheckTranslationAmbiguousFinding, &Self> {
        if let AutomatedReasoningCheckFinding::TranslationAmbiguous(val) = &self {
            ::std::result::Result::Ok(val)
        } else {
            ::std::result::Result::Err(self)
        }
    }
    /// Returns true if this is a [`TranslationAmbiguous`](crate::types::AutomatedReasoningCheckFinding::TranslationAmbiguous).
    pub fn is_translation_ambiguous(&self) -> bool {
        self.as_translation_ambiguous().is_ok()
    }
    /// Tries to convert the enum instance into [`Valid`](crate::types::AutomatedReasoningCheckFinding::Valid), extracting the inner [`AutomatedReasoningCheckValidFinding`](crate::types::AutomatedReasoningCheckValidFinding).
    /// Returns `Err(&Self)` if it can't be converted.
    pub fn as_valid(&self) -> ::std::result::Result<&crate::types::AutomatedReasoningCheckValidFinding, &Self> {
        if let AutomatedReasoningCheckFinding::Valid(val) = &self {
            ::std::result::Result::Ok(val)
        } else {
            ::std::result::Result::Err(self)
        }
    }
    /// Returns true if this is a [`Valid`](crate::types::AutomatedReasoningCheckFinding::Valid).
    pub fn is_valid(&self) -> bool {
        self.as_valid().is_ok()
    }
    /// Returns true if the enum instance is the `Unknown` variant.
    pub fn is_unknown(&self) -> bool {
        matches!(self, Self::Unknown)
    }
}
