// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.

/// <p>The configuration for TPS-based traffic shaping. This approach limits requests to the ad decision server (ADS) based on transactions per second and concurrent users, providing more intuitive capacity management compared to time-window based traffic shaping.</p>
#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::fmt::Debug)]
pub struct TrafficShapingTpsConfiguration {
    /// <p>The maximum number of transactions per second (TPS) that your ad decision server (ADS) can handle. MediaTailor uses this value along with concurrent users and headroom multiplier to calculate optimal traffic distribution and prevent ADS overload.</p>
    pub peak_tps: ::std::option::Option<i32>,
    /// <p>The expected peak number of concurrent viewers for your content. MediaTailor uses this value along with peak TPS to determine how to distribute prefetch requests across the available capacity without exceeding your ADS limits.</p>
    pub peak_concurrent_users: ::std::option::Option<i32>,
}
impl TrafficShapingTpsConfiguration {
    /// <p>The maximum number of transactions per second (TPS) that your ad decision server (ADS) can handle. MediaTailor uses this value along with concurrent users and headroom multiplier to calculate optimal traffic distribution and prevent ADS overload.</p>
    pub fn peak_tps(&self) -> ::std::option::Option<i32> {
        self.peak_tps
    }
    /// <p>The expected peak number of concurrent viewers for your content. MediaTailor uses this value along with peak TPS to determine how to distribute prefetch requests across the available capacity without exceeding your ADS limits.</p>
    pub fn peak_concurrent_users(&self) -> ::std::option::Option<i32> {
        self.peak_concurrent_users
    }
}
impl TrafficShapingTpsConfiguration {
    /// Creates a new builder-style object to manufacture [`TrafficShapingTpsConfiguration`](crate::types::TrafficShapingTpsConfiguration).
    pub fn builder() -> crate::types::builders::TrafficShapingTpsConfigurationBuilder {
        crate::types::builders::TrafficShapingTpsConfigurationBuilder::default()
    }
}

/// A builder for [`TrafficShapingTpsConfiguration`](crate::types::TrafficShapingTpsConfiguration).
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::default::Default, ::std::fmt::Debug)]
#[non_exhaustive]
pub struct TrafficShapingTpsConfigurationBuilder {
    pub(crate) peak_tps: ::std::option::Option<i32>,
    pub(crate) peak_concurrent_users: ::std::option::Option<i32>,
}
impl TrafficShapingTpsConfigurationBuilder {
    /// <p>The maximum number of transactions per second (TPS) that your ad decision server (ADS) can handle. MediaTailor uses this value along with concurrent users and headroom multiplier to calculate optimal traffic distribution and prevent ADS overload.</p>
    pub fn peak_tps(mut self, input: i32) -> Self {
        self.peak_tps = ::std::option::Option::Some(input);
        self
    }
    /// <p>The maximum number of transactions per second (TPS) that your ad decision server (ADS) can handle. MediaTailor uses this value along with concurrent users and headroom multiplier to calculate optimal traffic distribution and prevent ADS overload.</p>
    pub fn set_peak_tps(mut self, input: ::std::option::Option<i32>) -> Self {
        self.peak_tps = input;
        self
    }
    /// <p>The maximum number of transactions per second (TPS) that your ad decision server (ADS) can handle. MediaTailor uses this value along with concurrent users and headroom multiplier to calculate optimal traffic distribution and prevent ADS overload.</p>
    pub fn get_peak_tps(&self) -> &::std::option::Option<i32> {
        &self.peak_tps
    }
    /// <p>The expected peak number of concurrent viewers for your content. MediaTailor uses this value along with peak TPS to determine how to distribute prefetch requests across the available capacity without exceeding your ADS limits.</p>
    pub fn peak_concurrent_users(mut self, input: i32) -> Self {
        self.peak_concurrent_users = ::std::option::Option::Some(input);
        self
    }
    /// <p>The expected peak number of concurrent viewers for your content. MediaTailor uses this value along with peak TPS to determine how to distribute prefetch requests across the available capacity without exceeding your ADS limits.</p>
    pub fn set_peak_concurrent_users(mut self, input: ::std::option::Option<i32>) -> Self {
        self.peak_concurrent_users = input;
        self
    }
    /// <p>The expected peak number of concurrent viewers for your content. MediaTailor uses this value along with peak TPS to determine how to distribute prefetch requests across the available capacity without exceeding your ADS limits.</p>
    pub fn get_peak_concurrent_users(&self) -> &::std::option::Option<i32> {
        &self.peak_concurrent_users
    }
    /// Consumes the builder and constructs a [`TrafficShapingTpsConfiguration`](crate::types::TrafficShapingTpsConfiguration).
    pub fn build(self) -> crate::types::TrafficShapingTpsConfiguration {
        crate::types::TrafficShapingTpsConfiguration {
            peak_tps: self.peak_tps,
            peak_concurrent_users: self.peak_concurrent_users,
        }
    }
}
