// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
pub use crate::operation::update_container_group_definition::_update_container_group_definition_output::UpdateContainerGroupDefinitionOutputBuilder;

pub use crate::operation::update_container_group_definition::_update_container_group_definition_input::UpdateContainerGroupDefinitionInputBuilder;

impl crate::operation::update_container_group_definition::builders::UpdateContainerGroupDefinitionInputBuilder {
    /// Sends a request with this input using the given client.
    pub async fn send_with(
        self,
        client: &crate::Client,
    ) -> ::std::result::Result<
        crate::operation::update_container_group_definition::UpdateContainerGroupDefinitionOutput,
        ::aws_smithy_runtime_api::client::result::SdkError<
            crate::operation::update_container_group_definition::UpdateContainerGroupDefinitionError,
            ::aws_smithy_runtime_api::client::orchestrator::HttpResponse,
        >,
    > {
        let mut fluent_builder = client.update_container_group_definition();
        fluent_builder.inner = self;
        fluent_builder.send().await
    }
}
/// Fluent builder constructing a request to `UpdateContainerGroupDefinition`.
///
/// <p>Updates properties in an existing container group definition. This operation doesn't replace the definition. Instead, it creates a new version of the definition and saves it separately. You can access all versions that you choose to retain.</p>
/// <p>The only property you can't update is the container group type.</p>
/// <p><b>Request options:</b></p>
/// <ul>
/// <li>
/// <p>Update based on the latest version of the container group definition. Specify the container group definition name only, or use an ARN value without a version number. Provide updated values for the properties that you want to change only. All other values remain the same as the latest version.</p></li>
/// <li>
/// <p>Update based on a specific version of the container group definition. Specify the container group definition name and a source version number, or use an ARN value with a version number. Provide updated values for the properties that you want to change only. All other values remain the same as the source version.</p></li>
/// <li>
/// <p>Change a game server container definition. Provide the updated container definition.</p></li>
/// <li>
/// <p>Add or change a support container definition. Provide a complete set of container definitions, including the updated definition.</p></li>
/// <li>
/// <p>Remove a support container definition. Provide a complete set of container definitions, excluding the definition to remove. If the container group has only one support container definition, provide an empty set.</p></li>
/// </ul>
/// <p><b>Results:</b></p>
/// <p>If successful, this operation returns the complete properties of the new container group definition version.</p>
/// <p>If the container group definition version is used in an active fleets, the update automatically initiates a new fleet deployment of the new version. You can track a fleet's deployments using <a href="https://docs.aws.amazon.com/gamelift/latest/apireference/API_ListFleetDeployments.html">ListFleetDeployments</a>.</p>
#[derive(::std::clone::Clone, ::std::fmt::Debug)]
pub struct UpdateContainerGroupDefinitionFluentBuilder {
    handle: ::std::sync::Arc<crate::client::Handle>,
    inner: crate::operation::update_container_group_definition::builders::UpdateContainerGroupDefinitionInputBuilder,
    config_override: ::std::option::Option<crate::config::Builder>,
}
impl
    crate::client::customize::internal::CustomizableSend<
        crate::operation::update_container_group_definition::UpdateContainerGroupDefinitionOutput,
        crate::operation::update_container_group_definition::UpdateContainerGroupDefinitionError,
    > for UpdateContainerGroupDefinitionFluentBuilder
{
    fn send(
        self,
        config_override: crate::config::Builder,
    ) -> crate::client::customize::internal::BoxFuture<
        crate::client::customize::internal::SendResult<
            crate::operation::update_container_group_definition::UpdateContainerGroupDefinitionOutput,
            crate::operation::update_container_group_definition::UpdateContainerGroupDefinitionError,
        >,
    > {
        ::std::boxed::Box::pin(async move { self.config_override(config_override).send().await })
    }
}
impl UpdateContainerGroupDefinitionFluentBuilder {
    /// Creates a new `UpdateContainerGroupDefinitionFluentBuilder`.
    pub(crate) fn new(handle: ::std::sync::Arc<crate::client::Handle>) -> Self {
        Self {
            handle,
            inner: ::std::default::Default::default(),
            config_override: ::std::option::Option::None,
        }
    }
    /// Access the UpdateContainerGroupDefinition as a reference.
    pub fn as_input(&self) -> &crate::operation::update_container_group_definition::builders::UpdateContainerGroupDefinitionInputBuilder {
        &self.inner
    }
    /// Sends the request and returns the response.
    ///
    /// If an error occurs, an `SdkError` will be returned with additional details that
    /// can be matched against.
    ///
    /// By default, any retryable failures will be retried twice. Retry behavior
    /// is configurable with the [RetryConfig](aws_smithy_types::retry::RetryConfig), which can be
    /// set when configuring the client.
    pub async fn send(
        self,
    ) -> ::std::result::Result<
        crate::operation::update_container_group_definition::UpdateContainerGroupDefinitionOutput,
        ::aws_smithy_runtime_api::client::result::SdkError<
            crate::operation::update_container_group_definition::UpdateContainerGroupDefinitionError,
            ::aws_smithy_runtime_api::client::orchestrator::HttpResponse,
        >,
    > {
        let input = self
            .inner
            .build()
            .map_err(::aws_smithy_runtime_api::client::result::SdkError::construction_failure)?;
        let runtime_plugins = crate::operation::update_container_group_definition::UpdateContainerGroupDefinition::operation_runtime_plugins(
            self.handle.runtime_plugins.clone(),
            &self.handle.conf,
            self.config_override,
        );
        crate::operation::update_container_group_definition::UpdateContainerGroupDefinition::orchestrate(&runtime_plugins, input).await
    }

    /// Consumes this builder, creating a customizable operation that can be modified before being sent.
    pub fn customize(
        self,
    ) -> crate::client::customize::CustomizableOperation<
        crate::operation::update_container_group_definition::UpdateContainerGroupDefinitionOutput,
        crate::operation::update_container_group_definition::UpdateContainerGroupDefinitionError,
        Self,
    > {
        crate::client::customize::CustomizableOperation::new(self)
    }
    pub(crate) fn config_override(mut self, config_override: impl ::std::convert::Into<crate::config::Builder>) -> Self {
        self.set_config_override(::std::option::Option::Some(config_override.into()));
        self
    }

    pub(crate) fn set_config_override(&mut self, config_override: ::std::option::Option<crate::config::Builder>) -> &mut Self {
        self.config_override = config_override;
        self
    }
    /// <p>A descriptive identifier for the container group definition. The name value must be unique in an Amazon Web Services Region.</p>
    pub fn name(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.inner = self.inner.name(input.into());
        self
    }
    /// <p>A descriptive identifier for the container group definition. The name value must be unique in an Amazon Web Services Region.</p>
    pub fn set_name(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.inner = self.inner.set_name(input);
        self
    }
    /// <p>A descriptive identifier for the container group definition. The name value must be unique in an Amazon Web Services Region.</p>
    pub fn get_name(&self) -> &::std::option::Option<::std::string::String> {
        self.inner.get_name()
    }
    /// <p>An updated definition for the game server container in this group. Define a game server container only when the container group type is <code>GAME_SERVER</code>. You can pass in your container definitions as a JSON file.</p>
    pub fn game_server_container_definition(mut self, input: crate::types::GameServerContainerDefinitionInput) -> Self {
        self.inner = self.inner.game_server_container_definition(input);
        self
    }
    /// <p>An updated definition for the game server container in this group. Define a game server container only when the container group type is <code>GAME_SERVER</code>. You can pass in your container definitions as a JSON file.</p>
    pub fn set_game_server_container_definition(mut self, input: ::std::option::Option<crate::types::GameServerContainerDefinitionInput>) -> Self {
        self.inner = self.inner.set_game_server_container_definition(input);
        self
    }
    /// <p>An updated definition for the game server container in this group. Define a game server container only when the container group type is <code>GAME_SERVER</code>. You can pass in your container definitions as a JSON file.</p>
    pub fn get_game_server_container_definition(&self) -> &::std::option::Option<crate::types::GameServerContainerDefinitionInput> {
        self.inner.get_game_server_container_definition()
    }
    ///
    /// Appends an item to `SupportContainerDefinitions`.
    ///
    /// To override the contents of this collection use [`set_support_container_definitions`](Self::set_support_container_definitions).
    ///
    /// <p>One or more definitions for support containers in this group. You can define a support container in any type of container group. You can pass in your container definitions as a JSON file.</p>
    pub fn support_container_definitions(mut self, input: crate::types::SupportContainerDefinitionInput) -> Self {
        self.inner = self.inner.support_container_definitions(input);
        self
    }
    /// <p>One or more definitions for support containers in this group. You can define a support container in any type of container group. You can pass in your container definitions as a JSON file.</p>
    pub fn set_support_container_definitions(
        mut self,
        input: ::std::option::Option<::std::vec::Vec<crate::types::SupportContainerDefinitionInput>>,
    ) -> Self {
        self.inner = self.inner.set_support_container_definitions(input);
        self
    }
    /// <p>One or more definitions for support containers in this group. You can define a support container in any type of container group. You can pass in your container definitions as a JSON file.</p>
    pub fn get_support_container_definitions(&self) -> &::std::option::Option<::std::vec::Vec<crate::types::SupportContainerDefinitionInput>> {
        self.inner.get_support_container_definitions()
    }
    /// <p>The maximum amount of memory (in MiB) to allocate to the container group. All containers in the group share this memory. If you specify memory limits for an individual container, the total value must be greater than any individual container's memory limit.</p>
    pub fn total_memory_limit_mebibytes(mut self, input: i32) -> Self {
        self.inner = self.inner.total_memory_limit_mebibytes(input);
        self
    }
    /// <p>The maximum amount of memory (in MiB) to allocate to the container group. All containers in the group share this memory. If you specify memory limits for an individual container, the total value must be greater than any individual container's memory limit.</p>
    pub fn set_total_memory_limit_mebibytes(mut self, input: ::std::option::Option<i32>) -> Self {
        self.inner = self.inner.set_total_memory_limit_mebibytes(input);
        self
    }
    /// <p>The maximum amount of memory (in MiB) to allocate to the container group. All containers in the group share this memory. If you specify memory limits for an individual container, the total value must be greater than any individual container's memory limit.</p>
    pub fn get_total_memory_limit_mebibytes(&self) -> &::std::option::Option<i32> {
        self.inner.get_total_memory_limit_mebibytes()
    }
    /// <p>The maximum amount of vCPU units to allocate to the container group (1 vCPU is equal to 1024 CPU units). All containers in the group share this memory. If you specify vCPU limits for individual containers, the total value must be equal to or greater than the sum of the CPU limits for all containers in the group.</p>
    pub fn total_vcpu_limit(mut self, input: f64) -> Self {
        self.inner = self.inner.total_vcpu_limit(input);
        self
    }
    /// <p>The maximum amount of vCPU units to allocate to the container group (1 vCPU is equal to 1024 CPU units). All containers in the group share this memory. If you specify vCPU limits for individual containers, the total value must be equal to or greater than the sum of the CPU limits for all containers in the group.</p>
    pub fn set_total_vcpu_limit(mut self, input: ::std::option::Option<f64>) -> Self {
        self.inner = self.inner.set_total_vcpu_limit(input);
        self
    }
    /// <p>The maximum amount of vCPU units to allocate to the container group (1 vCPU is equal to 1024 CPU units). All containers in the group share this memory. If you specify vCPU limits for individual containers, the total value must be equal to or greater than the sum of the CPU limits for all containers in the group.</p>
    pub fn get_total_vcpu_limit(&self) -> &::std::option::Option<f64> {
        self.inner.get_total_vcpu_limit()
    }
    /// <p>A description for this update to the container group definition.</p>
    pub fn version_description(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.inner = self.inner.version_description(input.into());
        self
    }
    /// <p>A description for this update to the container group definition.</p>
    pub fn set_version_description(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.inner = self.inner.set_version_description(input);
        self
    }
    /// <p>A description for this update to the container group definition.</p>
    pub fn get_version_description(&self) -> &::std::option::Option<::std::string::String> {
        self.inner.get_version_description()
    }
    /// <p>The container group definition version to update. The new version starts with values from the source version, and then updates values included in this request.</p>
    pub fn source_version_number(mut self, input: i32) -> Self {
        self.inner = self.inner.source_version_number(input);
        self
    }
    /// <p>The container group definition version to update. The new version starts with values from the source version, and then updates values included in this request.</p>
    pub fn set_source_version_number(mut self, input: ::std::option::Option<i32>) -> Self {
        self.inner = self.inner.set_source_version_number(input);
        self
    }
    /// <p>The container group definition version to update. The new version starts with values from the source version, and then updates values included in this request.</p>
    pub fn get_source_version_number(&self) -> &::std::option::Option<i32> {
        self.inner.get_source_version_number()
    }
    /// <p>The platform that all containers in the group use. Containers in a group must run on the same operating system.</p><note>
    /// <p>Amazon Linux 2 (AL2) will reach end of support on 6/30/2025. See more details in the <a href="http://aws.amazon.com/amazon-linux-2/faqs/">Amazon Linux 2 FAQs</a>. For game servers that are hosted on AL2 and use server SDK version 4.x for Amazon GameLift Servers, first update the game server build to server SDK 5.x, and then deploy to AL2023 instances. See <a href="https://docs.aws.amazon.com/gamelift/latest/developerguide/reference-serversdk5-migration.html"> Migrate to server SDK version 5.</a></p>
    /// </note>
    pub fn operating_system(mut self, input: crate::types::ContainerOperatingSystem) -> Self {
        self.inner = self.inner.operating_system(input);
        self
    }
    /// <p>The platform that all containers in the group use. Containers in a group must run on the same operating system.</p><note>
    /// <p>Amazon Linux 2 (AL2) will reach end of support on 6/30/2025. See more details in the <a href="http://aws.amazon.com/amazon-linux-2/faqs/">Amazon Linux 2 FAQs</a>. For game servers that are hosted on AL2 and use server SDK version 4.x for Amazon GameLift Servers, first update the game server build to server SDK 5.x, and then deploy to AL2023 instances. See <a href="https://docs.aws.amazon.com/gamelift/latest/developerguide/reference-serversdk5-migration.html"> Migrate to server SDK version 5.</a></p>
    /// </note>
    pub fn set_operating_system(mut self, input: ::std::option::Option<crate::types::ContainerOperatingSystem>) -> Self {
        self.inner = self.inner.set_operating_system(input);
        self
    }
    /// <p>The platform that all containers in the group use. Containers in a group must run on the same operating system.</p><note>
    /// <p>Amazon Linux 2 (AL2) will reach end of support on 6/30/2025. See more details in the <a href="http://aws.amazon.com/amazon-linux-2/faqs/">Amazon Linux 2 FAQs</a>. For game servers that are hosted on AL2 and use server SDK version 4.x for Amazon GameLift Servers, first update the game server build to server SDK 5.x, and then deploy to AL2023 instances. See <a href="https://docs.aws.amazon.com/gamelift/latest/developerguide/reference-serversdk5-migration.html"> Migrate to server SDK version 5.</a></p>
    /// </note>
    pub fn get_operating_system(&self) -> &::std::option::Option<crate::types::ContainerOperatingSystem> {
        self.inner.get_operating_system()
    }
}
