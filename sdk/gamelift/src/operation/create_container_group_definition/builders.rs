// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
pub use crate::operation::create_container_group_definition::_create_container_group_definition_output::CreateContainerGroupDefinitionOutputBuilder;

pub use crate::operation::create_container_group_definition::_create_container_group_definition_input::CreateContainerGroupDefinitionInputBuilder;

impl crate::operation::create_container_group_definition::builders::CreateContainerGroupDefinitionInputBuilder {
    /// Sends a request with this input using the given client.
    pub async fn send_with(
        self,
        client: &crate::Client,
    ) -> ::std::result::Result<
        crate::operation::create_container_group_definition::CreateContainerGroupDefinitionOutput,
        ::aws_smithy_runtime_api::client::result::SdkError<
            crate::operation::create_container_group_definition::CreateContainerGroupDefinitionError,
            ::aws_smithy_runtime_api::client::orchestrator::HttpResponse,
        >,
    > {
        let mut fluent_builder = client.create_container_group_definition();
        fluent_builder.inner = self;
        fluent_builder.send().await
    }
}
/// Fluent builder constructing a request to `CreateContainerGroupDefinition`.
///
/// <p>Creates a <code>ContainerGroupDefinition</code> that describes a set of containers for hosting your game server with Amazon GameLift Servers managed containers hosting. An Amazon GameLift Servers container group is similar to a container task or pod. Use container group definitions when you create a container fleet with <a href="https://docs.aws.amazon.com/gamelift/latest/apireference/API_CreateContainerFleet.html">CreateContainerFleet</a>.</p>
/// <p>A container group definition determines how Amazon GameLift Servers deploys your containers to each instance in a container fleet. You can maintain multiple versions of a container group definition.</p>
/// <p>There are two types of container groups:</p>
/// <ul>
/// <li>
/// <p>A <b>game server container group</b> has the containers that run your game server application and supporting software. A game server container group can have these container types:</p>
/// <ul>
/// <li>
/// <p>Game server container. This container runs your game server. You can define one game server container in a game server container group.</p></li>
/// <li>
/// <p>Support container. This container runs software in parallel with your game server. You can define up to 8 support containers in a game server group.</p></li>
/// </ul>
/// <p>When building a game server container group definition, you can choose to bundle your game server executable and all dependent software into a single game server container. Alternatively, you can separate the software into one game server container and one or more support containers.</p>
/// <p>On a container fleet instance, a game server container group can be deployed multiple times (depending on the compute resources of the instance). This means that all containers in the container group are replicated together.</p></li>
/// <li>
/// <p>A <b>per-instance container group</b> has containers for processes that aren't replicated on a container fleet instance. This might include background services, logging, test processes, or processes that need to persist independently of the game server container group. When building a per-instance container group, you can define up to 10 support containers.</p></li>
/// </ul><note>
/// <p>This operation requires Identity and Access Management (IAM) permissions to access container images in Amazon ECR repositories. See <a href="https://docs.aws.amazon.com/gamelift/latest/developerguide/gamelift-iam-policy-examples.html"> IAM permissions for Amazon GameLift Servers</a> for help setting the appropriate permissions.</p>
/// </note>
/// <p><b>Request options</b></p>
/// <p>Use this operation to make the following types of requests. You can specify values for the minimum required parameters and customize optional values later.</p>
/// <ul>
/// <li>
/// <p>Create a game server container group definition. Provide the following required parameter values:</p>
/// <ul>
/// <li>
/// <p><code>Name</code></p></li>
/// <li>
/// <p><code>ContainerGroupType</code> (<code>GAME_SERVER</code>)</p></li>
/// <li>
/// <p><code>OperatingSystem</code> (omit to use default value)</p></li>
/// <li>
/// <p><code>TotalMemoryLimitMebibytes</code> (omit to use default value)</p></li>
/// <li>
/// <p><code>TotalVcpuLimit </code>(omit to use default value)</p></li>
/// <li>
/// <p>At least one <code>GameServerContainerDefinition</code></p>
/// <ul>
/// <li>
/// <p><code>ContainerName</code></p></li>
/// <li>
/// <p><code>ImageUrl</code></p></li>
/// <li>
/// <p><code>PortConfiguration</code></p></li>
/// <li>
/// <p><code>ServerSdkVersion</code> (omit to use default value)</p></li>
/// </ul></li>
/// </ul></li>
/// <li>
/// <p>Create a per-instance container group definition. Provide the following required parameter values:</p>
/// <ul>
/// <li>
/// <p><code>Name</code></p></li>
/// <li>
/// <p><code>ContainerGroupType</code> (<code>PER_INSTANCE</code>)</p></li>
/// <li>
/// <p><code>OperatingSystem</code> (omit to use default value)</p></li>
/// <li>
/// <p><code>TotalMemoryLimitMebibytes</code> (omit to use default value)</p></li>
/// <li>
/// <p><code>TotalVcpuLimit </code>(omit to use default value)</p></li>
/// <li>
/// <p>At least one <code>SupportContainerDefinition</code></p>
/// <ul>
/// <li>
/// <p><code>ContainerName</code></p></li>
/// <li>
/// <p><code>ImageUrl</code></p></li>
/// </ul></li>
/// </ul></li>
/// </ul>
/// <p><b>Results</b></p>
/// <p>If successful, this request creates a <code>ContainerGroupDefinition</code> resource and assigns a unique ARN value. You can update most properties of a container group definition by calling <a href="https://docs.aws.amazon.com/gamelift/latest/apireference/API_UpdateContainerGroupDefinition.html">UpdateContainerGroupDefinition</a>, and optionally save the update as a new version.</p>
#[derive(::std::clone::Clone, ::std::fmt::Debug)]
pub struct CreateContainerGroupDefinitionFluentBuilder {
    handle: ::std::sync::Arc<crate::client::Handle>,
    inner: crate::operation::create_container_group_definition::builders::CreateContainerGroupDefinitionInputBuilder,
    config_override: ::std::option::Option<crate::config::Builder>,
}
impl
    crate::client::customize::internal::CustomizableSend<
        crate::operation::create_container_group_definition::CreateContainerGroupDefinitionOutput,
        crate::operation::create_container_group_definition::CreateContainerGroupDefinitionError,
    > for CreateContainerGroupDefinitionFluentBuilder
{
    fn send(
        self,
        config_override: crate::config::Builder,
    ) -> crate::client::customize::internal::BoxFuture<
        crate::client::customize::internal::SendResult<
            crate::operation::create_container_group_definition::CreateContainerGroupDefinitionOutput,
            crate::operation::create_container_group_definition::CreateContainerGroupDefinitionError,
        >,
    > {
        ::std::boxed::Box::pin(async move { self.config_override(config_override).send().await })
    }
}
impl CreateContainerGroupDefinitionFluentBuilder {
    /// Creates a new `CreateContainerGroupDefinitionFluentBuilder`.
    pub(crate) fn new(handle: ::std::sync::Arc<crate::client::Handle>) -> Self {
        Self {
            handle,
            inner: ::std::default::Default::default(),
            config_override: ::std::option::Option::None,
        }
    }
    /// Access the CreateContainerGroupDefinition as a reference.
    pub fn as_input(&self) -> &crate::operation::create_container_group_definition::builders::CreateContainerGroupDefinitionInputBuilder {
        &self.inner
    }
    /// Sends the request and returns the response.
    ///
    /// If an error occurs, an `SdkError` will be returned with additional details that
    /// can be matched against.
    ///
    /// By default, any retryable failures will be retried twice. Retry behavior
    /// is configurable with the [RetryConfig](aws_smithy_types::retry::RetryConfig), which can be
    /// set when configuring the client.
    pub async fn send(
        self,
    ) -> ::std::result::Result<
        crate::operation::create_container_group_definition::CreateContainerGroupDefinitionOutput,
        ::aws_smithy_runtime_api::client::result::SdkError<
            crate::operation::create_container_group_definition::CreateContainerGroupDefinitionError,
            ::aws_smithy_runtime_api::client::orchestrator::HttpResponse,
        >,
    > {
        let input = self
            .inner
            .build()
            .map_err(::aws_smithy_runtime_api::client::result::SdkError::construction_failure)?;
        let runtime_plugins = crate::operation::create_container_group_definition::CreateContainerGroupDefinition::operation_runtime_plugins(
            self.handle.runtime_plugins.clone(),
            &self.handle.conf,
            self.config_override,
        );
        crate::operation::create_container_group_definition::CreateContainerGroupDefinition::orchestrate(&runtime_plugins, input).await
    }

    /// Consumes this builder, creating a customizable operation that can be modified before being sent.
    pub fn customize(
        self,
    ) -> crate::client::customize::CustomizableOperation<
        crate::operation::create_container_group_definition::CreateContainerGroupDefinitionOutput,
        crate::operation::create_container_group_definition::CreateContainerGroupDefinitionError,
        Self,
    > {
        crate::client::customize::CustomizableOperation::new(self)
    }
    pub(crate) fn config_override(mut self, config_override: impl ::std::convert::Into<crate::config::Builder>) -> Self {
        self.set_config_override(::std::option::Option::Some(config_override.into()));
        self
    }

    pub(crate) fn set_config_override(&mut self, config_override: ::std::option::Option<crate::config::Builder>) -> &mut Self {
        self.config_override = config_override;
        self
    }
    /// <p>A descriptive identifier for the container group definition. The name value must be unique in an Amazon Web Services Region.</p>
    pub fn name(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.inner = self.inner.name(input.into());
        self
    }
    /// <p>A descriptive identifier for the container group definition. The name value must be unique in an Amazon Web Services Region.</p>
    pub fn set_name(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.inner = self.inner.set_name(input);
        self
    }
    /// <p>A descriptive identifier for the container group definition. The name value must be unique in an Amazon Web Services Region.</p>
    pub fn get_name(&self) -> &::std::option::Option<::std::string::String> {
        self.inner.get_name()
    }
    /// <p>The type of container group being defined. Container group type determines how Amazon GameLift Servers deploys the container group on each fleet instance.</p>
    /// <p>Default value: <code>GAME_SERVER</code></p>
    pub fn container_group_type(mut self, input: crate::types::ContainerGroupType) -> Self {
        self.inner = self.inner.container_group_type(input);
        self
    }
    /// <p>The type of container group being defined. Container group type determines how Amazon GameLift Servers deploys the container group on each fleet instance.</p>
    /// <p>Default value: <code>GAME_SERVER</code></p>
    pub fn set_container_group_type(mut self, input: ::std::option::Option<crate::types::ContainerGroupType>) -> Self {
        self.inner = self.inner.set_container_group_type(input);
        self
    }
    /// <p>The type of container group being defined. Container group type determines how Amazon GameLift Servers deploys the container group on each fleet instance.</p>
    /// <p>Default value: <code>GAME_SERVER</code></p>
    pub fn get_container_group_type(&self) -> &::std::option::Option<crate::types::ContainerGroupType> {
        self.inner.get_container_group_type()
    }
    /// <p>The maximum amount of memory (in MiB) to allocate to the container group. All containers in the group share this memory. If you specify memory limits for an individual container, the total value must be greater than any individual container's memory limit.</p>
    /// <p>Default value: 1024</p>
    pub fn total_memory_limit_mebibytes(mut self, input: i32) -> Self {
        self.inner = self.inner.total_memory_limit_mebibytes(input);
        self
    }
    /// <p>The maximum amount of memory (in MiB) to allocate to the container group. All containers in the group share this memory. If you specify memory limits for an individual container, the total value must be greater than any individual container's memory limit.</p>
    /// <p>Default value: 1024</p>
    pub fn set_total_memory_limit_mebibytes(mut self, input: ::std::option::Option<i32>) -> Self {
        self.inner = self.inner.set_total_memory_limit_mebibytes(input);
        self
    }
    /// <p>The maximum amount of memory (in MiB) to allocate to the container group. All containers in the group share this memory. If you specify memory limits for an individual container, the total value must be greater than any individual container's memory limit.</p>
    /// <p>Default value: 1024</p>
    pub fn get_total_memory_limit_mebibytes(&self) -> &::std::option::Option<i32> {
        self.inner.get_total_memory_limit_mebibytes()
    }
    /// <p>The maximum amount of vCPU units to allocate to the container group (1 vCPU is equal to 1024 CPU units). All containers in the group share this memory. If you specify vCPU limits for individual containers, the total value must be equal to or greater than the sum of the CPU limits for all containers in the group.</p>
    /// <p>Default value: 1</p>
    pub fn total_vcpu_limit(mut self, input: f64) -> Self {
        self.inner = self.inner.total_vcpu_limit(input);
        self
    }
    /// <p>The maximum amount of vCPU units to allocate to the container group (1 vCPU is equal to 1024 CPU units). All containers in the group share this memory. If you specify vCPU limits for individual containers, the total value must be equal to or greater than the sum of the CPU limits for all containers in the group.</p>
    /// <p>Default value: 1</p>
    pub fn set_total_vcpu_limit(mut self, input: ::std::option::Option<f64>) -> Self {
        self.inner = self.inner.set_total_vcpu_limit(input);
        self
    }
    /// <p>The maximum amount of vCPU units to allocate to the container group (1 vCPU is equal to 1024 CPU units). All containers in the group share this memory. If you specify vCPU limits for individual containers, the total value must be equal to or greater than the sum of the CPU limits for all containers in the group.</p>
    /// <p>Default value: 1</p>
    pub fn get_total_vcpu_limit(&self) -> &::std::option::Option<f64> {
        self.inner.get_total_vcpu_limit()
    }
    /// <p>The definition for the game server container in this group. Define a game server container only when the container group type is <code>GAME_SERVER</code>. Game server containers specify a container image with your game server build. You can pass in your container definitions as a JSON file.</p>
    pub fn game_server_container_definition(mut self, input: crate::types::GameServerContainerDefinitionInput) -> Self {
        self.inner = self.inner.game_server_container_definition(input);
        self
    }
    /// <p>The definition for the game server container in this group. Define a game server container only when the container group type is <code>GAME_SERVER</code>. Game server containers specify a container image with your game server build. You can pass in your container definitions as a JSON file.</p>
    pub fn set_game_server_container_definition(mut self, input: ::std::option::Option<crate::types::GameServerContainerDefinitionInput>) -> Self {
        self.inner = self.inner.set_game_server_container_definition(input);
        self
    }
    /// <p>The definition for the game server container in this group. Define a game server container only when the container group type is <code>GAME_SERVER</code>. Game server containers specify a container image with your game server build. You can pass in your container definitions as a JSON file.</p>
    pub fn get_game_server_container_definition(&self) -> &::std::option::Option<crate::types::GameServerContainerDefinitionInput> {
        self.inner.get_game_server_container_definition()
    }
    ///
    /// Appends an item to `SupportContainerDefinitions`.
    ///
    /// To override the contents of this collection use [`set_support_container_definitions`](Self::set_support_container_definitions).
    ///
    /// <p>One or more definition for support containers in this group. You can define a support container in any type of container group. You can pass in your container definitions as a JSON file.</p>
    pub fn support_container_definitions(mut self, input: crate::types::SupportContainerDefinitionInput) -> Self {
        self.inner = self.inner.support_container_definitions(input);
        self
    }
    /// <p>One or more definition for support containers in this group. You can define a support container in any type of container group. You can pass in your container definitions as a JSON file.</p>
    pub fn set_support_container_definitions(
        mut self,
        input: ::std::option::Option<::std::vec::Vec<crate::types::SupportContainerDefinitionInput>>,
    ) -> Self {
        self.inner = self.inner.set_support_container_definitions(input);
        self
    }
    /// <p>One or more definition for support containers in this group. You can define a support container in any type of container group. You can pass in your container definitions as a JSON file.</p>
    pub fn get_support_container_definitions(&self) -> &::std::option::Option<::std::vec::Vec<crate::types::SupportContainerDefinitionInput>> {
        self.inner.get_support_container_definitions()
    }
    /// <p>The platform that all containers in the group use. Containers in a group must run on the same operating system.</p>
    /// <p>Default value: <code>AMAZON_LINUX_2023</code></p><note>
    /// <p>Amazon Linux 2 (AL2) will reach end of support on 6/30/2025. See more details in the <a href="http://aws.amazon.com/amazon-linux-2/faqs/">Amazon Linux 2 FAQs</a>. For game servers that are hosted on AL2 and use server SDK version 4.x for Amazon GameLift Servers, first update the game server build to server SDK 5.x, and then deploy to AL2023 instances. See <a href="https://docs.aws.amazon.com/gamelift/latest/developerguide/reference-serversdk5-migration.html"> Migrate to server SDK version 5.</a></p>
    /// </note>
    pub fn operating_system(mut self, input: crate::types::ContainerOperatingSystem) -> Self {
        self.inner = self.inner.operating_system(input);
        self
    }
    /// <p>The platform that all containers in the group use. Containers in a group must run on the same operating system.</p>
    /// <p>Default value: <code>AMAZON_LINUX_2023</code></p><note>
    /// <p>Amazon Linux 2 (AL2) will reach end of support on 6/30/2025. See more details in the <a href="http://aws.amazon.com/amazon-linux-2/faqs/">Amazon Linux 2 FAQs</a>. For game servers that are hosted on AL2 and use server SDK version 4.x for Amazon GameLift Servers, first update the game server build to server SDK 5.x, and then deploy to AL2023 instances. See <a href="https://docs.aws.amazon.com/gamelift/latest/developerguide/reference-serversdk5-migration.html"> Migrate to server SDK version 5.</a></p>
    /// </note>
    pub fn set_operating_system(mut self, input: ::std::option::Option<crate::types::ContainerOperatingSystem>) -> Self {
        self.inner = self.inner.set_operating_system(input);
        self
    }
    /// <p>The platform that all containers in the group use. Containers in a group must run on the same operating system.</p>
    /// <p>Default value: <code>AMAZON_LINUX_2023</code></p><note>
    /// <p>Amazon Linux 2 (AL2) will reach end of support on 6/30/2025. See more details in the <a href="http://aws.amazon.com/amazon-linux-2/faqs/">Amazon Linux 2 FAQs</a>. For game servers that are hosted on AL2 and use server SDK version 4.x for Amazon GameLift Servers, first update the game server build to server SDK 5.x, and then deploy to AL2023 instances. See <a href="https://docs.aws.amazon.com/gamelift/latest/developerguide/reference-serversdk5-migration.html"> Migrate to server SDK version 5.</a></p>
    /// </note>
    pub fn get_operating_system(&self) -> &::std::option::Option<crate::types::ContainerOperatingSystem> {
        self.inner.get_operating_system()
    }
    /// <p>A description for the initial version of this container group definition.</p>
    pub fn version_description(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.inner = self.inner.version_description(input.into());
        self
    }
    /// <p>A description for the initial version of this container group definition.</p>
    pub fn set_version_description(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.inner = self.inner.set_version_description(input);
        self
    }
    /// <p>A description for the initial version of this container group definition.</p>
    pub fn get_version_description(&self) -> &::std::option::Option<::std::string::String> {
        self.inner.get_version_description()
    }
    ///
    /// Appends an item to `Tags`.
    ///
    /// To override the contents of this collection use [`set_tags`](Self::set_tags).
    ///
    /// <p>A list of labels to assign to the container group definition resource. Tags are developer-defined key-value pairs. Tagging Amazon Web Services resources are useful for resource management, access management and cost allocation. For more information, see <a href="https://docs.aws.amazon.com/general/latest/gr/aws_tagging.html"> Tagging Amazon Web Services Resources</a> in the <i>Amazon Web Services General Reference</i>.</p>
    pub fn tags(mut self, input: crate::types::Tag) -> Self {
        self.inner = self.inner.tags(input);
        self
    }
    /// <p>A list of labels to assign to the container group definition resource. Tags are developer-defined key-value pairs. Tagging Amazon Web Services resources are useful for resource management, access management and cost allocation. For more information, see <a href="https://docs.aws.amazon.com/general/latest/gr/aws_tagging.html"> Tagging Amazon Web Services Resources</a> in the <i>Amazon Web Services General Reference</i>.</p>
    pub fn set_tags(mut self, input: ::std::option::Option<::std::vec::Vec<crate::types::Tag>>) -> Self {
        self.inner = self.inner.set_tags(input);
        self
    }
    /// <p>A list of labels to assign to the container group definition resource. Tags are developer-defined key-value pairs. Tagging Amazon Web Services resources are useful for resource management, access management and cost allocation. For more information, see <a href="https://docs.aws.amazon.com/general/latest/gr/aws_tagging.html"> Tagging Amazon Web Services Resources</a> in the <i>Amazon Web Services General Reference</i>.</p>
    pub fn get_tags(&self) -> &::std::option::Option<::std::vec::Vec<crate::types::Tag>> {
        self.inner.get_tags()
    }
}
