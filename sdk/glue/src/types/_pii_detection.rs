// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.

/// <p>Specifies a transform that identifies, removes or masks PII data.</p>
#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::fmt::Debug)]
pub struct PiiDetection {
    /// <p>The name of the transform node.</p>
    pub name: ::std::string::String,
    /// <p>The node ID inputs to the transform.</p>
    pub inputs: ::std::vec::Vec<::std::string::String>,
    /// <p>Indicates the type of PIIDetection transform.</p>
    pub pii_type: crate::types::PiiType,
    /// <p>Indicates the types of entities the PIIDetection transform will identify as PII data.</p>
    /// <p>PII type entities include: PERSON_NAME, DATE, USA_SNN, EMAIL, USA_ITIN, USA_PASSPORT_NUMBER, PHONE_NUMBER, BANK_ACCOUNT, IP_ADDRESS, MAC_ADDRESS, USA_CPT_CODE, USA_HCPCS_CODE, USA_NATIONAL_DRUG_CODE, USA_MEDICARE_BENEFICIARY_IDENTIFIER, USA_HEALTH_INSURANCE_CLAIM_NUMBER,CREDIT_CARD,USA_NATIONAL_PROVIDER_IDENTIFIER,USA_DEA_NUMBER,USA_DRIVING_LICENSE</p>
    pub entity_types_to_detect: ::std::vec::Vec<::std::string::String>,
    /// <p>Indicates the output column name that will contain any entity type detected in that row.</p>
    pub output_column_name: ::std::option::Option<::std::string::String>,
    /// <p>Indicates the fraction of the data to sample when scanning for PII entities.</p>
    pub sample_fraction: ::std::option::Option<f64>,
    /// <p>Indicates the fraction of the data that must be met in order for a column to be identified as PII data.</p>
    pub threshold_fraction: ::std::option::Option<f64>,
    /// <p>Indicates the value that will replace the detected entity.</p>
    pub mask_value: ::std::option::Option<::std::string::String>,
    /// <p>Specifies whether to redact the detected PII text. When set to <code>true</code>, PII content is replaced with redaction characters.</p>
    pub redact_text: ::std::option::Option<::std::string::String>,
    /// <p>The character used to replace detected PII content when redaction is enabled. The default redaction character is <code>*</code>.</p>
    pub redact_char: ::std::option::Option<::std::string::String>,
    /// <p>A regular expression pattern used to identify additional PII content beyond the standard detection algorithms.</p>
    pub match_pattern: ::std::option::Option<::std::string::String>,
    /// <p>The number of characters to exclude from redaction on the left side of detected PII content. This allows preserving context around the sensitive data.</p>
    pub num_left_chars_to_exclude: ::std::option::Option<i32>,
    /// <p>The number of characters to exclude from redaction on the right side of detected PII content. This allows preserving context around the sensitive data.</p>
    pub num_right_chars_to_exclude: ::std::option::Option<i32>,
    /// <p>Additional parameters for configuring PII detection behavior and sensitivity settings.</p>
    pub detection_parameters: ::std::option::Option<::std::string::String>,
    /// <p>The sensitivity level for PII detection. Higher sensitivity levels detect more potential PII but may result in more false positives.</p>
    pub detection_sensitivity: ::std::option::Option<::std::string::String>,
}
impl PiiDetection {
    /// <p>The name of the transform node.</p>
    pub fn name(&self) -> &str {
        use std::ops::Deref;
        self.name.deref()
    }
    /// <p>The node ID inputs to the transform.</p>
    pub fn inputs(&self) -> &[::std::string::String] {
        use std::ops::Deref;
        self.inputs.deref()
    }
    /// <p>Indicates the type of PIIDetection transform.</p>
    pub fn pii_type(&self) -> &crate::types::PiiType {
        &self.pii_type
    }
    /// <p>Indicates the types of entities the PIIDetection transform will identify as PII data.</p>
    /// <p>PII type entities include: PERSON_NAME, DATE, USA_SNN, EMAIL, USA_ITIN, USA_PASSPORT_NUMBER, PHONE_NUMBER, BANK_ACCOUNT, IP_ADDRESS, MAC_ADDRESS, USA_CPT_CODE, USA_HCPCS_CODE, USA_NATIONAL_DRUG_CODE, USA_MEDICARE_BENEFICIARY_IDENTIFIER, USA_HEALTH_INSURANCE_CLAIM_NUMBER,CREDIT_CARD,USA_NATIONAL_PROVIDER_IDENTIFIER,USA_DEA_NUMBER,USA_DRIVING_LICENSE</p>
    pub fn entity_types_to_detect(&self) -> &[::std::string::String] {
        use std::ops::Deref;
        self.entity_types_to_detect.deref()
    }
    /// <p>Indicates the output column name that will contain any entity type detected in that row.</p>
    pub fn output_column_name(&self) -> ::std::option::Option<&str> {
        self.output_column_name.as_deref()
    }
    /// <p>Indicates the fraction of the data to sample when scanning for PII entities.</p>
    pub fn sample_fraction(&self) -> ::std::option::Option<f64> {
        self.sample_fraction
    }
    /// <p>Indicates the fraction of the data that must be met in order for a column to be identified as PII data.</p>
    pub fn threshold_fraction(&self) -> ::std::option::Option<f64> {
        self.threshold_fraction
    }
    /// <p>Indicates the value that will replace the detected entity.</p>
    pub fn mask_value(&self) -> ::std::option::Option<&str> {
        self.mask_value.as_deref()
    }
    /// <p>Specifies whether to redact the detected PII text. When set to <code>true</code>, PII content is replaced with redaction characters.</p>
    pub fn redact_text(&self) -> ::std::option::Option<&str> {
        self.redact_text.as_deref()
    }
    /// <p>The character used to replace detected PII content when redaction is enabled. The default redaction character is <code>*</code>.</p>
    pub fn redact_char(&self) -> ::std::option::Option<&str> {
        self.redact_char.as_deref()
    }
    /// <p>A regular expression pattern used to identify additional PII content beyond the standard detection algorithms.</p>
    pub fn match_pattern(&self) -> ::std::option::Option<&str> {
        self.match_pattern.as_deref()
    }
    /// <p>The number of characters to exclude from redaction on the left side of detected PII content. This allows preserving context around the sensitive data.</p>
    pub fn num_left_chars_to_exclude(&self) -> ::std::option::Option<i32> {
        self.num_left_chars_to_exclude
    }
    /// <p>The number of characters to exclude from redaction on the right side of detected PII content. This allows preserving context around the sensitive data.</p>
    pub fn num_right_chars_to_exclude(&self) -> ::std::option::Option<i32> {
        self.num_right_chars_to_exclude
    }
    /// <p>Additional parameters for configuring PII detection behavior and sensitivity settings.</p>
    pub fn detection_parameters(&self) -> ::std::option::Option<&str> {
        self.detection_parameters.as_deref()
    }
    /// <p>The sensitivity level for PII detection. Higher sensitivity levels detect more potential PII but may result in more false positives.</p>
    pub fn detection_sensitivity(&self) -> ::std::option::Option<&str> {
        self.detection_sensitivity.as_deref()
    }
}
impl PiiDetection {
    /// Creates a new builder-style object to manufacture [`PiiDetection`](crate::types::PiiDetection).
    pub fn builder() -> crate::types::builders::PiiDetectionBuilder {
        crate::types::builders::PiiDetectionBuilder::default()
    }
}

/// A builder for [`PiiDetection`](crate::types::PiiDetection).
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::default::Default, ::std::fmt::Debug)]
#[non_exhaustive]
pub struct PiiDetectionBuilder {
    pub(crate) name: ::std::option::Option<::std::string::String>,
    pub(crate) inputs: ::std::option::Option<::std::vec::Vec<::std::string::String>>,
    pub(crate) pii_type: ::std::option::Option<crate::types::PiiType>,
    pub(crate) entity_types_to_detect: ::std::option::Option<::std::vec::Vec<::std::string::String>>,
    pub(crate) output_column_name: ::std::option::Option<::std::string::String>,
    pub(crate) sample_fraction: ::std::option::Option<f64>,
    pub(crate) threshold_fraction: ::std::option::Option<f64>,
    pub(crate) mask_value: ::std::option::Option<::std::string::String>,
    pub(crate) redact_text: ::std::option::Option<::std::string::String>,
    pub(crate) redact_char: ::std::option::Option<::std::string::String>,
    pub(crate) match_pattern: ::std::option::Option<::std::string::String>,
    pub(crate) num_left_chars_to_exclude: ::std::option::Option<i32>,
    pub(crate) num_right_chars_to_exclude: ::std::option::Option<i32>,
    pub(crate) detection_parameters: ::std::option::Option<::std::string::String>,
    pub(crate) detection_sensitivity: ::std::option::Option<::std::string::String>,
}
impl PiiDetectionBuilder {
    /// <p>The name of the transform node.</p>
    /// This field is required.
    pub fn name(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.name = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The name of the transform node.</p>
    pub fn set_name(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.name = input;
        self
    }
    /// <p>The name of the transform node.</p>
    pub fn get_name(&self) -> &::std::option::Option<::std::string::String> {
        &self.name
    }
    /// Appends an item to `inputs`.
    ///
    /// To override the contents of this collection use [`set_inputs`](Self::set_inputs).
    ///
    /// <p>The node ID inputs to the transform.</p>
    pub fn inputs(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        let mut v = self.inputs.unwrap_or_default();
        v.push(input.into());
        self.inputs = ::std::option::Option::Some(v);
        self
    }
    /// <p>The node ID inputs to the transform.</p>
    pub fn set_inputs(mut self, input: ::std::option::Option<::std::vec::Vec<::std::string::String>>) -> Self {
        self.inputs = input;
        self
    }
    /// <p>The node ID inputs to the transform.</p>
    pub fn get_inputs(&self) -> &::std::option::Option<::std::vec::Vec<::std::string::String>> {
        &self.inputs
    }
    /// <p>Indicates the type of PIIDetection transform.</p>
    /// This field is required.
    pub fn pii_type(mut self, input: crate::types::PiiType) -> Self {
        self.pii_type = ::std::option::Option::Some(input);
        self
    }
    /// <p>Indicates the type of PIIDetection transform.</p>
    pub fn set_pii_type(mut self, input: ::std::option::Option<crate::types::PiiType>) -> Self {
        self.pii_type = input;
        self
    }
    /// <p>Indicates the type of PIIDetection transform.</p>
    pub fn get_pii_type(&self) -> &::std::option::Option<crate::types::PiiType> {
        &self.pii_type
    }
    /// Appends an item to `entity_types_to_detect`.
    ///
    /// To override the contents of this collection use [`set_entity_types_to_detect`](Self::set_entity_types_to_detect).
    ///
    /// <p>Indicates the types of entities the PIIDetection transform will identify as PII data.</p>
    /// <p>PII type entities include: PERSON_NAME, DATE, USA_SNN, EMAIL, USA_ITIN, USA_PASSPORT_NUMBER, PHONE_NUMBER, BANK_ACCOUNT, IP_ADDRESS, MAC_ADDRESS, USA_CPT_CODE, USA_HCPCS_CODE, USA_NATIONAL_DRUG_CODE, USA_MEDICARE_BENEFICIARY_IDENTIFIER, USA_HEALTH_INSURANCE_CLAIM_NUMBER,CREDIT_CARD,USA_NATIONAL_PROVIDER_IDENTIFIER,USA_DEA_NUMBER,USA_DRIVING_LICENSE</p>
    pub fn entity_types_to_detect(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        let mut v = self.entity_types_to_detect.unwrap_or_default();
        v.push(input.into());
        self.entity_types_to_detect = ::std::option::Option::Some(v);
        self
    }
    /// <p>Indicates the types of entities the PIIDetection transform will identify as PII data.</p>
    /// <p>PII type entities include: PERSON_NAME, DATE, USA_SNN, EMAIL, USA_ITIN, USA_PASSPORT_NUMBER, PHONE_NUMBER, BANK_ACCOUNT, IP_ADDRESS, MAC_ADDRESS, USA_CPT_CODE, USA_HCPCS_CODE, USA_NATIONAL_DRUG_CODE, USA_MEDICARE_BENEFICIARY_IDENTIFIER, USA_HEALTH_INSURANCE_CLAIM_NUMBER,CREDIT_CARD,USA_NATIONAL_PROVIDER_IDENTIFIER,USA_DEA_NUMBER,USA_DRIVING_LICENSE</p>
    pub fn set_entity_types_to_detect(mut self, input: ::std::option::Option<::std::vec::Vec<::std::string::String>>) -> Self {
        self.entity_types_to_detect = input;
        self
    }
    /// <p>Indicates the types of entities the PIIDetection transform will identify as PII data.</p>
    /// <p>PII type entities include: PERSON_NAME, DATE, USA_SNN, EMAIL, USA_ITIN, USA_PASSPORT_NUMBER, PHONE_NUMBER, BANK_ACCOUNT, IP_ADDRESS, MAC_ADDRESS, USA_CPT_CODE, USA_HCPCS_CODE, USA_NATIONAL_DRUG_CODE, USA_MEDICARE_BENEFICIARY_IDENTIFIER, USA_HEALTH_INSURANCE_CLAIM_NUMBER,CREDIT_CARD,USA_NATIONAL_PROVIDER_IDENTIFIER,USA_DEA_NUMBER,USA_DRIVING_LICENSE</p>
    pub fn get_entity_types_to_detect(&self) -> &::std::option::Option<::std::vec::Vec<::std::string::String>> {
        &self.entity_types_to_detect
    }
    /// <p>Indicates the output column name that will contain any entity type detected in that row.</p>
    pub fn output_column_name(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.output_column_name = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>Indicates the output column name that will contain any entity type detected in that row.</p>
    pub fn set_output_column_name(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.output_column_name = input;
        self
    }
    /// <p>Indicates the output column name that will contain any entity type detected in that row.</p>
    pub fn get_output_column_name(&self) -> &::std::option::Option<::std::string::String> {
        &self.output_column_name
    }
    /// <p>Indicates the fraction of the data to sample when scanning for PII entities.</p>
    pub fn sample_fraction(mut self, input: f64) -> Self {
        self.sample_fraction = ::std::option::Option::Some(input);
        self
    }
    /// <p>Indicates the fraction of the data to sample when scanning for PII entities.</p>
    pub fn set_sample_fraction(mut self, input: ::std::option::Option<f64>) -> Self {
        self.sample_fraction = input;
        self
    }
    /// <p>Indicates the fraction of the data to sample when scanning for PII entities.</p>
    pub fn get_sample_fraction(&self) -> &::std::option::Option<f64> {
        &self.sample_fraction
    }
    /// <p>Indicates the fraction of the data that must be met in order for a column to be identified as PII data.</p>
    pub fn threshold_fraction(mut self, input: f64) -> Self {
        self.threshold_fraction = ::std::option::Option::Some(input);
        self
    }
    /// <p>Indicates the fraction of the data that must be met in order for a column to be identified as PII data.</p>
    pub fn set_threshold_fraction(mut self, input: ::std::option::Option<f64>) -> Self {
        self.threshold_fraction = input;
        self
    }
    /// <p>Indicates the fraction of the data that must be met in order for a column to be identified as PII data.</p>
    pub fn get_threshold_fraction(&self) -> &::std::option::Option<f64> {
        &self.threshold_fraction
    }
    /// <p>Indicates the value that will replace the detected entity.</p>
    pub fn mask_value(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.mask_value = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>Indicates the value that will replace the detected entity.</p>
    pub fn set_mask_value(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.mask_value = input;
        self
    }
    /// <p>Indicates the value that will replace the detected entity.</p>
    pub fn get_mask_value(&self) -> &::std::option::Option<::std::string::String> {
        &self.mask_value
    }
    /// <p>Specifies whether to redact the detected PII text. When set to <code>true</code>, PII content is replaced with redaction characters.</p>
    pub fn redact_text(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.redact_text = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>Specifies whether to redact the detected PII text. When set to <code>true</code>, PII content is replaced with redaction characters.</p>
    pub fn set_redact_text(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.redact_text = input;
        self
    }
    /// <p>Specifies whether to redact the detected PII text. When set to <code>true</code>, PII content is replaced with redaction characters.</p>
    pub fn get_redact_text(&self) -> &::std::option::Option<::std::string::String> {
        &self.redact_text
    }
    /// <p>The character used to replace detected PII content when redaction is enabled. The default redaction character is <code>*</code>.</p>
    pub fn redact_char(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.redact_char = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The character used to replace detected PII content when redaction is enabled. The default redaction character is <code>*</code>.</p>
    pub fn set_redact_char(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.redact_char = input;
        self
    }
    /// <p>The character used to replace detected PII content when redaction is enabled. The default redaction character is <code>*</code>.</p>
    pub fn get_redact_char(&self) -> &::std::option::Option<::std::string::String> {
        &self.redact_char
    }
    /// <p>A regular expression pattern used to identify additional PII content beyond the standard detection algorithms.</p>
    pub fn match_pattern(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.match_pattern = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>A regular expression pattern used to identify additional PII content beyond the standard detection algorithms.</p>
    pub fn set_match_pattern(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.match_pattern = input;
        self
    }
    /// <p>A regular expression pattern used to identify additional PII content beyond the standard detection algorithms.</p>
    pub fn get_match_pattern(&self) -> &::std::option::Option<::std::string::String> {
        &self.match_pattern
    }
    /// <p>The number of characters to exclude from redaction on the left side of detected PII content. This allows preserving context around the sensitive data.</p>
    pub fn num_left_chars_to_exclude(mut self, input: i32) -> Self {
        self.num_left_chars_to_exclude = ::std::option::Option::Some(input);
        self
    }
    /// <p>The number of characters to exclude from redaction on the left side of detected PII content. This allows preserving context around the sensitive data.</p>
    pub fn set_num_left_chars_to_exclude(mut self, input: ::std::option::Option<i32>) -> Self {
        self.num_left_chars_to_exclude = input;
        self
    }
    /// <p>The number of characters to exclude from redaction on the left side of detected PII content. This allows preserving context around the sensitive data.</p>
    pub fn get_num_left_chars_to_exclude(&self) -> &::std::option::Option<i32> {
        &self.num_left_chars_to_exclude
    }
    /// <p>The number of characters to exclude from redaction on the right side of detected PII content. This allows preserving context around the sensitive data.</p>
    pub fn num_right_chars_to_exclude(mut self, input: i32) -> Self {
        self.num_right_chars_to_exclude = ::std::option::Option::Some(input);
        self
    }
    /// <p>The number of characters to exclude from redaction on the right side of detected PII content. This allows preserving context around the sensitive data.</p>
    pub fn set_num_right_chars_to_exclude(mut self, input: ::std::option::Option<i32>) -> Self {
        self.num_right_chars_to_exclude = input;
        self
    }
    /// <p>The number of characters to exclude from redaction on the right side of detected PII content. This allows preserving context around the sensitive data.</p>
    pub fn get_num_right_chars_to_exclude(&self) -> &::std::option::Option<i32> {
        &self.num_right_chars_to_exclude
    }
    /// <p>Additional parameters for configuring PII detection behavior and sensitivity settings.</p>
    pub fn detection_parameters(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.detection_parameters = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>Additional parameters for configuring PII detection behavior and sensitivity settings.</p>
    pub fn set_detection_parameters(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.detection_parameters = input;
        self
    }
    /// <p>Additional parameters for configuring PII detection behavior and sensitivity settings.</p>
    pub fn get_detection_parameters(&self) -> &::std::option::Option<::std::string::String> {
        &self.detection_parameters
    }
    /// <p>The sensitivity level for PII detection. Higher sensitivity levels detect more potential PII but may result in more false positives.</p>
    pub fn detection_sensitivity(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.detection_sensitivity = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The sensitivity level for PII detection. Higher sensitivity levels detect more potential PII but may result in more false positives.</p>
    pub fn set_detection_sensitivity(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.detection_sensitivity = input;
        self
    }
    /// <p>The sensitivity level for PII detection. Higher sensitivity levels detect more potential PII but may result in more false positives.</p>
    pub fn get_detection_sensitivity(&self) -> &::std::option::Option<::std::string::String> {
        &self.detection_sensitivity
    }
    /// Consumes the builder and constructs a [`PiiDetection`](crate::types::PiiDetection).
    /// This method will fail if any of the following fields are not set:
    /// - [`name`](crate::types::builders::PiiDetectionBuilder::name)
    /// - [`inputs`](crate::types::builders::PiiDetectionBuilder::inputs)
    /// - [`pii_type`](crate::types::builders::PiiDetectionBuilder::pii_type)
    /// - [`entity_types_to_detect`](crate::types::builders::PiiDetectionBuilder::entity_types_to_detect)
    pub fn build(self) -> ::std::result::Result<crate::types::PiiDetection, ::aws_smithy_types::error::operation::BuildError> {
        ::std::result::Result::Ok(crate::types::PiiDetection {
            name: self.name.ok_or_else(|| {
                ::aws_smithy_types::error::operation::BuildError::missing_field(
                    "name",
                    "name was not specified but it is required when building PiiDetection",
                )
            })?,
            inputs: self.inputs.ok_or_else(|| {
                ::aws_smithy_types::error::operation::BuildError::missing_field(
                    "inputs",
                    "inputs was not specified but it is required when building PiiDetection",
                )
            })?,
            pii_type: self.pii_type.ok_or_else(|| {
                ::aws_smithy_types::error::operation::BuildError::missing_field(
                    "pii_type",
                    "pii_type was not specified but it is required when building PiiDetection",
                )
            })?,
            entity_types_to_detect: self.entity_types_to_detect.ok_or_else(|| {
                ::aws_smithy_types::error::operation::BuildError::missing_field(
                    "entity_types_to_detect",
                    "entity_types_to_detect was not specified but it is required when building PiiDetection",
                )
            })?,
            output_column_name: self.output_column_name,
            sample_fraction: self.sample_fraction,
            threshold_fraction: self.threshold_fraction,
            mask_value: self.mask_value,
            redact_text: self.redact_text,
            redact_char: self.redact_char,
            match_pattern: self.match_pattern,
            num_left_chars_to_exclude: self.num_left_chars_to_exclude,
            num_right_chars_to_exclude: self.num_right_chars_to_exclude,
            detection_parameters: self.detection_parameters,
            detection_sensitivity: self.detection_sensitivity,
        })
    }
}
