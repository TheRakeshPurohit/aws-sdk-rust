// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.

/// <p>The instance requirements for attribute-based instance type selection. Instead of specifying exact instance types, you define requirements such as vCPU count, memory size, network performance, and accelerator specifications. Amazon ECS automatically selects Amazon EC2 instance types that match these requirements, providing flexibility and helping to mitigate capacity constraints.</p>
#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::fmt::Debug)]
pub struct InstanceRequirementsRequest {
    /// <p>The minimum and maximum number of vCPUs for the instance types. Amazon ECS selects instance types that have vCPU counts within this range.</p>
    pub v_cpu_count: ::std::option::Option<crate::types::VCpuCountRangeRequest>,
    /// <p>The minimum and maximum amount of memory in mebibytes (MiB) for the instance types. Amazon ECS selects instance types that have memory within this range.</p>
    pub memory_mib: ::std::option::Option<crate::types::MemoryMiBRequest>,
    /// <p>The CPU manufacturers to include or exclude. You can specify <code>intel</code>, <code>amd</code>, or <code>amazon-web-services</code> to control which CPU types are used for your workloads.</p>
    pub cpu_manufacturers: ::std::option::Option<::std::vec::Vec<crate::types::CpuManufacturer>>,
    /// <p>The minimum and maximum amount of memory per vCPU in gibibytes (GiB). This helps ensure that instance types have the appropriate memory-to-CPU ratio for your workloads.</p>
    pub memory_gib_per_v_cpu: ::std::option::Option<crate::types::MemoryGiBPerVCpuRequest>,
    /// <p>The instance types to exclude from selection. Use this to prevent Amazon ECS from selecting specific instance types that may not be suitable for your workloads.</p>
    pub excluded_instance_types: ::std::option::Option<::std::vec::Vec<::std::string::String>>,
    /// <p>The instance generations to include. You can specify <code>current</code> to use the latest generation instances, or <code>previous</code> to include previous generation instances for cost optimization.</p>
    pub instance_generations: ::std::option::Option<::std::vec::Vec<crate::types::InstanceGeneration>>,
    /// <p>The maximum price for Spot instances as a percentage over the lowest priced On-Demand instance. This helps control Spot instance costs while maintaining access to capacity.</p>
    pub spot_max_price_percentage_over_lowest_price: ::std::option::Option<i32>,
    /// <p>The price protection threshold for On-Demand Instances, as a percentage higher than an identified On-Demand price. The identified On-Demand price is the price of the lowest priced current generation C, M, or R instance type with your specified attributes. If no current generation C, M, or R instance type matches your attributes, then the identified price is from either the lowest priced current generation instance types or, failing that, the lowest priced previous generation instance types that match your attributes. When Amazon ECS selects instance types with your attributes, we will exclude instance types whose price exceeds your specified threshold.</p>
    pub on_demand_max_price_percentage_over_lowest_price: ::std::option::Option<i32>,
    /// <p>Indicates whether to include bare metal instance types. Set to <code>included</code> to allow bare metal instances, <code>excluded</code> to exclude them, or <code>required</code> to use only bare metal instances.</p>
    pub bare_metal: ::std::option::Option<crate::types::BareMetal>,
    /// <p>Indicates whether to include burstable performance instance types (T2, T3, T3a, T4g). Set to <code>included</code> to allow burstable instances, <code>excluded</code> to exclude them, or <code>required</code> to use only burstable instances.</p>
    pub burstable_performance: ::std::option::Option<crate::types::BurstablePerformance>,
    /// <p>Indicates whether the instance types must support hibernation. When set to <code>true</code>, only instance types that support hibernation are selected.</p>
    pub require_hibernate_support: ::std::option::Option<bool>,
    /// <p>The minimum and maximum number of network interfaces for the instance types. This is useful for workloads that require multiple network interfaces.</p>
    pub network_interface_count: ::std::option::Option<crate::types::NetworkInterfaceCountRequest>,
    /// <p>Indicates whether to include instance types with local storage. Set to <code>included</code> to allow local storage, <code>excluded</code> to exclude it, or <code>required</code> to use only instances with local storage.</p>
    pub local_storage: ::std::option::Option<crate::types::LocalStorage>,
    /// <p>The local storage types to include. You can specify <code>hdd</code> for hard disk drives, <code>ssd</code> for solid state drives, or both.</p>
    pub local_storage_types: ::std::option::Option<::std::vec::Vec<crate::types::LocalStorageType>>,
    /// <p>The minimum and maximum total local storage in gigabytes (GB) for instance types with local storage.</p>
    pub total_local_storage_gb: ::std::option::Option<crate::types::TotalLocalStorageGbRequest>,
    /// <p>The minimum and maximum baseline Amazon EBS bandwidth in megabits per second (Mbps). This is important for workloads with high storage I/O requirements.</p>
    pub baseline_ebs_bandwidth_mbps: ::std::option::Option<crate::types::BaselineEbsBandwidthMbpsRequest>,
    /// <p>The accelerator types to include. You can specify <code>gpu</code> for graphics processing units, <code>fpga</code> for field programmable gate arrays, or <code>inference</code> for machine learning inference accelerators.</p>
    pub accelerator_types: ::std::option::Option<::std::vec::Vec<crate::types::AcceleratorType>>,
    /// <p>The minimum and maximum number of accelerators for the instance types. This is used when you need instances with specific numbers of GPUs or other accelerators.</p>
    pub accelerator_count: ::std::option::Option<crate::types::AcceleratorCountRequest>,
    /// <p>The accelerator manufacturers to include. You can specify <code>nvidia</code>, <code>amd</code>, <code>amazon-web-services</code>, or <code>xilinx</code> depending on your accelerator requirements.</p>
    pub accelerator_manufacturers: ::std::option::Option<::std::vec::Vec<crate::types::AcceleratorManufacturer>>,
    /// <p>The specific accelerator names to include. For example, you can specify <code>a100</code>, <code>v100</code>, <code>k80</code>, or other specific accelerator models.</p>
    pub accelerator_names: ::std::option::Option<::std::vec::Vec<crate::types::AcceleratorName>>,
    /// <p>The minimum and maximum total accelerator memory in mebibytes (MiB). This is important for GPU workloads that require specific amounts of video memory.</p>
    pub accelerator_total_memory_mib: ::std::option::Option<crate::types::AcceleratorTotalMemoryMiBRequest>,
    /// <p>The minimum and maximum network bandwidth in gigabits per second (Gbps). This is crucial for network-intensive workloads that require high throughput.</p>
    pub network_bandwidth_gbps: ::std::option::Option<crate::types::NetworkBandwidthGbpsRequest>,
    /// <p>The instance types to include in the selection. When specified, Amazon ECS only considers these instance types, subject to the other requirements specified.</p>
    pub allowed_instance_types: ::std::option::Option<::std::vec::Vec<::std::string::String>>,
    /// <p>The maximum price for Spot instances as a percentage of the optimal On-Demand price. This provides more precise cost control for Spot instance selection.</p>
    pub max_spot_price_as_percentage_of_optimal_on_demand_price: ::std::option::Option<i32>,
}
impl InstanceRequirementsRequest {
    /// <p>The minimum and maximum number of vCPUs for the instance types. Amazon ECS selects instance types that have vCPU counts within this range.</p>
    pub fn v_cpu_count(&self) -> ::std::option::Option<&crate::types::VCpuCountRangeRequest> {
        self.v_cpu_count.as_ref()
    }
    /// <p>The minimum and maximum amount of memory in mebibytes (MiB) for the instance types. Amazon ECS selects instance types that have memory within this range.</p>
    pub fn memory_mib(&self) -> ::std::option::Option<&crate::types::MemoryMiBRequest> {
        self.memory_mib.as_ref()
    }
    /// <p>The CPU manufacturers to include or exclude. You can specify <code>intel</code>, <code>amd</code>, or <code>amazon-web-services</code> to control which CPU types are used for your workloads.</p>
    ///
    /// If no value was sent for this field, a default will be set. If you want to determine if no value was sent, use `.cpu_manufacturers.is_none()`.
    pub fn cpu_manufacturers(&self) -> &[crate::types::CpuManufacturer] {
        self.cpu_manufacturers.as_deref().unwrap_or_default()
    }
    /// <p>The minimum and maximum amount of memory per vCPU in gibibytes (GiB). This helps ensure that instance types have the appropriate memory-to-CPU ratio for your workloads.</p>
    pub fn memory_gib_per_v_cpu(&self) -> ::std::option::Option<&crate::types::MemoryGiBPerVCpuRequest> {
        self.memory_gib_per_v_cpu.as_ref()
    }
    /// <p>The instance types to exclude from selection. Use this to prevent Amazon ECS from selecting specific instance types that may not be suitable for your workloads.</p>
    ///
    /// If no value was sent for this field, a default will be set. If you want to determine if no value was sent, use `.excluded_instance_types.is_none()`.
    pub fn excluded_instance_types(&self) -> &[::std::string::String] {
        self.excluded_instance_types.as_deref().unwrap_or_default()
    }
    /// <p>The instance generations to include. You can specify <code>current</code> to use the latest generation instances, or <code>previous</code> to include previous generation instances for cost optimization.</p>
    ///
    /// If no value was sent for this field, a default will be set. If you want to determine if no value was sent, use `.instance_generations.is_none()`.
    pub fn instance_generations(&self) -> &[crate::types::InstanceGeneration] {
        self.instance_generations.as_deref().unwrap_or_default()
    }
    /// <p>The maximum price for Spot instances as a percentage over the lowest priced On-Demand instance. This helps control Spot instance costs while maintaining access to capacity.</p>
    pub fn spot_max_price_percentage_over_lowest_price(&self) -> ::std::option::Option<i32> {
        self.spot_max_price_percentage_over_lowest_price
    }
    /// <p>The price protection threshold for On-Demand Instances, as a percentage higher than an identified On-Demand price. The identified On-Demand price is the price of the lowest priced current generation C, M, or R instance type with your specified attributes. If no current generation C, M, or R instance type matches your attributes, then the identified price is from either the lowest priced current generation instance types or, failing that, the lowest priced previous generation instance types that match your attributes. When Amazon ECS selects instance types with your attributes, we will exclude instance types whose price exceeds your specified threshold.</p>
    pub fn on_demand_max_price_percentage_over_lowest_price(&self) -> ::std::option::Option<i32> {
        self.on_demand_max_price_percentage_over_lowest_price
    }
    /// <p>Indicates whether to include bare metal instance types. Set to <code>included</code> to allow bare metal instances, <code>excluded</code> to exclude them, or <code>required</code> to use only bare metal instances.</p>
    pub fn bare_metal(&self) -> ::std::option::Option<&crate::types::BareMetal> {
        self.bare_metal.as_ref()
    }
    /// <p>Indicates whether to include burstable performance instance types (T2, T3, T3a, T4g). Set to <code>included</code> to allow burstable instances, <code>excluded</code> to exclude them, or <code>required</code> to use only burstable instances.</p>
    pub fn burstable_performance(&self) -> ::std::option::Option<&crate::types::BurstablePerformance> {
        self.burstable_performance.as_ref()
    }
    /// <p>Indicates whether the instance types must support hibernation. When set to <code>true</code>, only instance types that support hibernation are selected.</p>
    pub fn require_hibernate_support(&self) -> ::std::option::Option<bool> {
        self.require_hibernate_support
    }
    /// <p>The minimum and maximum number of network interfaces for the instance types. This is useful for workloads that require multiple network interfaces.</p>
    pub fn network_interface_count(&self) -> ::std::option::Option<&crate::types::NetworkInterfaceCountRequest> {
        self.network_interface_count.as_ref()
    }
    /// <p>Indicates whether to include instance types with local storage. Set to <code>included</code> to allow local storage, <code>excluded</code> to exclude it, or <code>required</code> to use only instances with local storage.</p>
    pub fn local_storage(&self) -> ::std::option::Option<&crate::types::LocalStorage> {
        self.local_storage.as_ref()
    }
    /// <p>The local storage types to include. You can specify <code>hdd</code> for hard disk drives, <code>ssd</code> for solid state drives, or both.</p>
    ///
    /// If no value was sent for this field, a default will be set. If you want to determine if no value was sent, use `.local_storage_types.is_none()`.
    pub fn local_storage_types(&self) -> &[crate::types::LocalStorageType] {
        self.local_storage_types.as_deref().unwrap_or_default()
    }
    /// <p>The minimum and maximum total local storage in gigabytes (GB) for instance types with local storage.</p>
    pub fn total_local_storage_gb(&self) -> ::std::option::Option<&crate::types::TotalLocalStorageGbRequest> {
        self.total_local_storage_gb.as_ref()
    }
    /// <p>The minimum and maximum baseline Amazon EBS bandwidth in megabits per second (Mbps). This is important for workloads with high storage I/O requirements.</p>
    pub fn baseline_ebs_bandwidth_mbps(&self) -> ::std::option::Option<&crate::types::BaselineEbsBandwidthMbpsRequest> {
        self.baseline_ebs_bandwidth_mbps.as_ref()
    }
    /// <p>The accelerator types to include. You can specify <code>gpu</code> for graphics processing units, <code>fpga</code> for field programmable gate arrays, or <code>inference</code> for machine learning inference accelerators.</p>
    ///
    /// If no value was sent for this field, a default will be set. If you want to determine if no value was sent, use `.accelerator_types.is_none()`.
    pub fn accelerator_types(&self) -> &[crate::types::AcceleratorType] {
        self.accelerator_types.as_deref().unwrap_or_default()
    }
    /// <p>The minimum and maximum number of accelerators for the instance types. This is used when you need instances with specific numbers of GPUs or other accelerators.</p>
    pub fn accelerator_count(&self) -> ::std::option::Option<&crate::types::AcceleratorCountRequest> {
        self.accelerator_count.as_ref()
    }
    /// <p>The accelerator manufacturers to include. You can specify <code>nvidia</code>, <code>amd</code>, <code>amazon-web-services</code>, or <code>xilinx</code> depending on your accelerator requirements.</p>
    ///
    /// If no value was sent for this field, a default will be set. If you want to determine if no value was sent, use `.accelerator_manufacturers.is_none()`.
    pub fn accelerator_manufacturers(&self) -> &[crate::types::AcceleratorManufacturer] {
        self.accelerator_manufacturers.as_deref().unwrap_or_default()
    }
    /// <p>The specific accelerator names to include. For example, you can specify <code>a100</code>, <code>v100</code>, <code>k80</code>, or other specific accelerator models.</p>
    ///
    /// If no value was sent for this field, a default will be set. If you want to determine if no value was sent, use `.accelerator_names.is_none()`.
    pub fn accelerator_names(&self) -> &[crate::types::AcceleratorName] {
        self.accelerator_names.as_deref().unwrap_or_default()
    }
    /// <p>The minimum and maximum total accelerator memory in mebibytes (MiB). This is important for GPU workloads that require specific amounts of video memory.</p>
    pub fn accelerator_total_memory_mib(&self) -> ::std::option::Option<&crate::types::AcceleratorTotalMemoryMiBRequest> {
        self.accelerator_total_memory_mib.as_ref()
    }
    /// <p>The minimum and maximum network bandwidth in gigabits per second (Gbps). This is crucial for network-intensive workloads that require high throughput.</p>
    pub fn network_bandwidth_gbps(&self) -> ::std::option::Option<&crate::types::NetworkBandwidthGbpsRequest> {
        self.network_bandwidth_gbps.as_ref()
    }
    /// <p>The instance types to include in the selection. When specified, Amazon ECS only considers these instance types, subject to the other requirements specified.</p>
    ///
    /// If no value was sent for this field, a default will be set. If you want to determine if no value was sent, use `.allowed_instance_types.is_none()`.
    pub fn allowed_instance_types(&self) -> &[::std::string::String] {
        self.allowed_instance_types.as_deref().unwrap_or_default()
    }
    /// <p>The maximum price for Spot instances as a percentage of the optimal On-Demand price. This provides more precise cost control for Spot instance selection.</p>
    pub fn max_spot_price_as_percentage_of_optimal_on_demand_price(&self) -> ::std::option::Option<i32> {
        self.max_spot_price_as_percentage_of_optimal_on_demand_price
    }
}
impl InstanceRequirementsRequest {
    /// Creates a new builder-style object to manufacture [`InstanceRequirementsRequest`](crate::types::InstanceRequirementsRequest).
    pub fn builder() -> crate::types::builders::InstanceRequirementsRequestBuilder {
        crate::types::builders::InstanceRequirementsRequestBuilder::default()
    }
}

/// A builder for [`InstanceRequirementsRequest`](crate::types::InstanceRequirementsRequest).
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::default::Default, ::std::fmt::Debug)]
#[non_exhaustive]
pub struct InstanceRequirementsRequestBuilder {
    pub(crate) v_cpu_count: ::std::option::Option<crate::types::VCpuCountRangeRequest>,
    pub(crate) memory_mib: ::std::option::Option<crate::types::MemoryMiBRequest>,
    pub(crate) cpu_manufacturers: ::std::option::Option<::std::vec::Vec<crate::types::CpuManufacturer>>,
    pub(crate) memory_gib_per_v_cpu: ::std::option::Option<crate::types::MemoryGiBPerVCpuRequest>,
    pub(crate) excluded_instance_types: ::std::option::Option<::std::vec::Vec<::std::string::String>>,
    pub(crate) instance_generations: ::std::option::Option<::std::vec::Vec<crate::types::InstanceGeneration>>,
    pub(crate) spot_max_price_percentage_over_lowest_price: ::std::option::Option<i32>,
    pub(crate) on_demand_max_price_percentage_over_lowest_price: ::std::option::Option<i32>,
    pub(crate) bare_metal: ::std::option::Option<crate::types::BareMetal>,
    pub(crate) burstable_performance: ::std::option::Option<crate::types::BurstablePerformance>,
    pub(crate) require_hibernate_support: ::std::option::Option<bool>,
    pub(crate) network_interface_count: ::std::option::Option<crate::types::NetworkInterfaceCountRequest>,
    pub(crate) local_storage: ::std::option::Option<crate::types::LocalStorage>,
    pub(crate) local_storage_types: ::std::option::Option<::std::vec::Vec<crate::types::LocalStorageType>>,
    pub(crate) total_local_storage_gb: ::std::option::Option<crate::types::TotalLocalStorageGbRequest>,
    pub(crate) baseline_ebs_bandwidth_mbps: ::std::option::Option<crate::types::BaselineEbsBandwidthMbpsRequest>,
    pub(crate) accelerator_types: ::std::option::Option<::std::vec::Vec<crate::types::AcceleratorType>>,
    pub(crate) accelerator_count: ::std::option::Option<crate::types::AcceleratorCountRequest>,
    pub(crate) accelerator_manufacturers: ::std::option::Option<::std::vec::Vec<crate::types::AcceleratorManufacturer>>,
    pub(crate) accelerator_names: ::std::option::Option<::std::vec::Vec<crate::types::AcceleratorName>>,
    pub(crate) accelerator_total_memory_mib: ::std::option::Option<crate::types::AcceleratorTotalMemoryMiBRequest>,
    pub(crate) network_bandwidth_gbps: ::std::option::Option<crate::types::NetworkBandwidthGbpsRequest>,
    pub(crate) allowed_instance_types: ::std::option::Option<::std::vec::Vec<::std::string::String>>,
    pub(crate) max_spot_price_as_percentage_of_optimal_on_demand_price: ::std::option::Option<i32>,
}
impl InstanceRequirementsRequestBuilder {
    /// <p>The minimum and maximum number of vCPUs for the instance types. Amazon ECS selects instance types that have vCPU counts within this range.</p>
    /// This field is required.
    pub fn v_cpu_count(mut self, input: crate::types::VCpuCountRangeRequest) -> Self {
        self.v_cpu_count = ::std::option::Option::Some(input);
        self
    }
    /// <p>The minimum and maximum number of vCPUs for the instance types. Amazon ECS selects instance types that have vCPU counts within this range.</p>
    pub fn set_v_cpu_count(mut self, input: ::std::option::Option<crate::types::VCpuCountRangeRequest>) -> Self {
        self.v_cpu_count = input;
        self
    }
    /// <p>The minimum and maximum number of vCPUs for the instance types. Amazon ECS selects instance types that have vCPU counts within this range.</p>
    pub fn get_v_cpu_count(&self) -> &::std::option::Option<crate::types::VCpuCountRangeRequest> {
        &self.v_cpu_count
    }
    /// <p>The minimum and maximum amount of memory in mebibytes (MiB) for the instance types. Amazon ECS selects instance types that have memory within this range.</p>
    /// This field is required.
    pub fn memory_mib(mut self, input: crate::types::MemoryMiBRequest) -> Self {
        self.memory_mib = ::std::option::Option::Some(input);
        self
    }
    /// <p>The minimum and maximum amount of memory in mebibytes (MiB) for the instance types. Amazon ECS selects instance types that have memory within this range.</p>
    pub fn set_memory_mib(mut self, input: ::std::option::Option<crate::types::MemoryMiBRequest>) -> Self {
        self.memory_mib = input;
        self
    }
    /// <p>The minimum and maximum amount of memory in mebibytes (MiB) for the instance types. Amazon ECS selects instance types that have memory within this range.</p>
    pub fn get_memory_mib(&self) -> &::std::option::Option<crate::types::MemoryMiBRequest> {
        &self.memory_mib
    }
    /// Appends an item to `cpu_manufacturers`.
    ///
    /// To override the contents of this collection use [`set_cpu_manufacturers`](Self::set_cpu_manufacturers).
    ///
    /// <p>The CPU manufacturers to include or exclude. You can specify <code>intel</code>, <code>amd</code>, or <code>amazon-web-services</code> to control which CPU types are used for your workloads.</p>
    pub fn cpu_manufacturers(mut self, input: crate::types::CpuManufacturer) -> Self {
        let mut v = self.cpu_manufacturers.unwrap_or_default();
        v.push(input);
        self.cpu_manufacturers = ::std::option::Option::Some(v);
        self
    }
    /// <p>The CPU manufacturers to include or exclude. You can specify <code>intel</code>, <code>amd</code>, or <code>amazon-web-services</code> to control which CPU types are used for your workloads.</p>
    pub fn set_cpu_manufacturers(mut self, input: ::std::option::Option<::std::vec::Vec<crate::types::CpuManufacturer>>) -> Self {
        self.cpu_manufacturers = input;
        self
    }
    /// <p>The CPU manufacturers to include or exclude. You can specify <code>intel</code>, <code>amd</code>, or <code>amazon-web-services</code> to control which CPU types are used for your workloads.</p>
    pub fn get_cpu_manufacturers(&self) -> &::std::option::Option<::std::vec::Vec<crate::types::CpuManufacturer>> {
        &self.cpu_manufacturers
    }
    /// <p>The minimum and maximum amount of memory per vCPU in gibibytes (GiB). This helps ensure that instance types have the appropriate memory-to-CPU ratio for your workloads.</p>
    pub fn memory_gib_per_v_cpu(mut self, input: crate::types::MemoryGiBPerVCpuRequest) -> Self {
        self.memory_gib_per_v_cpu = ::std::option::Option::Some(input);
        self
    }
    /// <p>The minimum and maximum amount of memory per vCPU in gibibytes (GiB). This helps ensure that instance types have the appropriate memory-to-CPU ratio for your workloads.</p>
    pub fn set_memory_gib_per_v_cpu(mut self, input: ::std::option::Option<crate::types::MemoryGiBPerVCpuRequest>) -> Self {
        self.memory_gib_per_v_cpu = input;
        self
    }
    /// <p>The minimum and maximum amount of memory per vCPU in gibibytes (GiB). This helps ensure that instance types have the appropriate memory-to-CPU ratio for your workloads.</p>
    pub fn get_memory_gib_per_v_cpu(&self) -> &::std::option::Option<crate::types::MemoryGiBPerVCpuRequest> {
        &self.memory_gib_per_v_cpu
    }
    /// Appends an item to `excluded_instance_types`.
    ///
    /// To override the contents of this collection use [`set_excluded_instance_types`](Self::set_excluded_instance_types).
    ///
    /// <p>The instance types to exclude from selection. Use this to prevent Amazon ECS from selecting specific instance types that may not be suitable for your workloads.</p>
    pub fn excluded_instance_types(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        let mut v = self.excluded_instance_types.unwrap_or_default();
        v.push(input.into());
        self.excluded_instance_types = ::std::option::Option::Some(v);
        self
    }
    /// <p>The instance types to exclude from selection. Use this to prevent Amazon ECS from selecting specific instance types that may not be suitable for your workloads.</p>
    pub fn set_excluded_instance_types(mut self, input: ::std::option::Option<::std::vec::Vec<::std::string::String>>) -> Self {
        self.excluded_instance_types = input;
        self
    }
    /// <p>The instance types to exclude from selection. Use this to prevent Amazon ECS from selecting specific instance types that may not be suitable for your workloads.</p>
    pub fn get_excluded_instance_types(&self) -> &::std::option::Option<::std::vec::Vec<::std::string::String>> {
        &self.excluded_instance_types
    }
    /// Appends an item to `instance_generations`.
    ///
    /// To override the contents of this collection use [`set_instance_generations`](Self::set_instance_generations).
    ///
    /// <p>The instance generations to include. You can specify <code>current</code> to use the latest generation instances, or <code>previous</code> to include previous generation instances for cost optimization.</p>
    pub fn instance_generations(mut self, input: crate::types::InstanceGeneration) -> Self {
        let mut v = self.instance_generations.unwrap_or_default();
        v.push(input);
        self.instance_generations = ::std::option::Option::Some(v);
        self
    }
    /// <p>The instance generations to include. You can specify <code>current</code> to use the latest generation instances, or <code>previous</code> to include previous generation instances for cost optimization.</p>
    pub fn set_instance_generations(mut self, input: ::std::option::Option<::std::vec::Vec<crate::types::InstanceGeneration>>) -> Self {
        self.instance_generations = input;
        self
    }
    /// <p>The instance generations to include. You can specify <code>current</code> to use the latest generation instances, or <code>previous</code> to include previous generation instances for cost optimization.</p>
    pub fn get_instance_generations(&self) -> &::std::option::Option<::std::vec::Vec<crate::types::InstanceGeneration>> {
        &self.instance_generations
    }
    /// <p>The maximum price for Spot instances as a percentage over the lowest priced On-Demand instance. This helps control Spot instance costs while maintaining access to capacity.</p>
    pub fn spot_max_price_percentage_over_lowest_price(mut self, input: i32) -> Self {
        self.spot_max_price_percentage_over_lowest_price = ::std::option::Option::Some(input);
        self
    }
    /// <p>The maximum price for Spot instances as a percentage over the lowest priced On-Demand instance. This helps control Spot instance costs while maintaining access to capacity.</p>
    pub fn set_spot_max_price_percentage_over_lowest_price(mut self, input: ::std::option::Option<i32>) -> Self {
        self.spot_max_price_percentage_over_lowest_price = input;
        self
    }
    /// <p>The maximum price for Spot instances as a percentage over the lowest priced On-Demand instance. This helps control Spot instance costs while maintaining access to capacity.</p>
    pub fn get_spot_max_price_percentage_over_lowest_price(&self) -> &::std::option::Option<i32> {
        &self.spot_max_price_percentage_over_lowest_price
    }
    /// <p>The price protection threshold for On-Demand Instances, as a percentage higher than an identified On-Demand price. The identified On-Demand price is the price of the lowest priced current generation C, M, or R instance type with your specified attributes. If no current generation C, M, or R instance type matches your attributes, then the identified price is from either the lowest priced current generation instance types or, failing that, the lowest priced previous generation instance types that match your attributes. When Amazon ECS selects instance types with your attributes, we will exclude instance types whose price exceeds your specified threshold.</p>
    pub fn on_demand_max_price_percentage_over_lowest_price(mut self, input: i32) -> Self {
        self.on_demand_max_price_percentage_over_lowest_price = ::std::option::Option::Some(input);
        self
    }
    /// <p>The price protection threshold for On-Demand Instances, as a percentage higher than an identified On-Demand price. The identified On-Demand price is the price of the lowest priced current generation C, M, or R instance type with your specified attributes. If no current generation C, M, or R instance type matches your attributes, then the identified price is from either the lowest priced current generation instance types or, failing that, the lowest priced previous generation instance types that match your attributes. When Amazon ECS selects instance types with your attributes, we will exclude instance types whose price exceeds your specified threshold.</p>
    pub fn set_on_demand_max_price_percentage_over_lowest_price(mut self, input: ::std::option::Option<i32>) -> Self {
        self.on_demand_max_price_percentage_over_lowest_price = input;
        self
    }
    /// <p>The price protection threshold for On-Demand Instances, as a percentage higher than an identified On-Demand price. The identified On-Demand price is the price of the lowest priced current generation C, M, or R instance type with your specified attributes. If no current generation C, M, or R instance type matches your attributes, then the identified price is from either the lowest priced current generation instance types or, failing that, the lowest priced previous generation instance types that match your attributes. When Amazon ECS selects instance types with your attributes, we will exclude instance types whose price exceeds your specified threshold.</p>
    pub fn get_on_demand_max_price_percentage_over_lowest_price(&self) -> &::std::option::Option<i32> {
        &self.on_demand_max_price_percentage_over_lowest_price
    }
    /// <p>Indicates whether to include bare metal instance types. Set to <code>included</code> to allow bare metal instances, <code>excluded</code> to exclude them, or <code>required</code> to use only bare metal instances.</p>
    pub fn bare_metal(mut self, input: crate::types::BareMetal) -> Self {
        self.bare_metal = ::std::option::Option::Some(input);
        self
    }
    /// <p>Indicates whether to include bare metal instance types. Set to <code>included</code> to allow bare metal instances, <code>excluded</code> to exclude them, or <code>required</code> to use only bare metal instances.</p>
    pub fn set_bare_metal(mut self, input: ::std::option::Option<crate::types::BareMetal>) -> Self {
        self.bare_metal = input;
        self
    }
    /// <p>Indicates whether to include bare metal instance types. Set to <code>included</code> to allow bare metal instances, <code>excluded</code> to exclude them, or <code>required</code> to use only bare metal instances.</p>
    pub fn get_bare_metal(&self) -> &::std::option::Option<crate::types::BareMetal> {
        &self.bare_metal
    }
    /// <p>Indicates whether to include burstable performance instance types (T2, T3, T3a, T4g). Set to <code>included</code> to allow burstable instances, <code>excluded</code> to exclude them, or <code>required</code> to use only burstable instances.</p>
    pub fn burstable_performance(mut self, input: crate::types::BurstablePerformance) -> Self {
        self.burstable_performance = ::std::option::Option::Some(input);
        self
    }
    /// <p>Indicates whether to include burstable performance instance types (T2, T3, T3a, T4g). Set to <code>included</code> to allow burstable instances, <code>excluded</code> to exclude them, or <code>required</code> to use only burstable instances.</p>
    pub fn set_burstable_performance(mut self, input: ::std::option::Option<crate::types::BurstablePerformance>) -> Self {
        self.burstable_performance = input;
        self
    }
    /// <p>Indicates whether to include burstable performance instance types (T2, T3, T3a, T4g). Set to <code>included</code> to allow burstable instances, <code>excluded</code> to exclude them, or <code>required</code> to use only burstable instances.</p>
    pub fn get_burstable_performance(&self) -> &::std::option::Option<crate::types::BurstablePerformance> {
        &self.burstable_performance
    }
    /// <p>Indicates whether the instance types must support hibernation. When set to <code>true</code>, only instance types that support hibernation are selected.</p>
    pub fn require_hibernate_support(mut self, input: bool) -> Self {
        self.require_hibernate_support = ::std::option::Option::Some(input);
        self
    }
    /// <p>Indicates whether the instance types must support hibernation. When set to <code>true</code>, only instance types that support hibernation are selected.</p>
    pub fn set_require_hibernate_support(mut self, input: ::std::option::Option<bool>) -> Self {
        self.require_hibernate_support = input;
        self
    }
    /// <p>Indicates whether the instance types must support hibernation. When set to <code>true</code>, only instance types that support hibernation are selected.</p>
    pub fn get_require_hibernate_support(&self) -> &::std::option::Option<bool> {
        &self.require_hibernate_support
    }
    /// <p>The minimum and maximum number of network interfaces for the instance types. This is useful for workloads that require multiple network interfaces.</p>
    pub fn network_interface_count(mut self, input: crate::types::NetworkInterfaceCountRequest) -> Self {
        self.network_interface_count = ::std::option::Option::Some(input);
        self
    }
    /// <p>The minimum and maximum number of network interfaces for the instance types. This is useful for workloads that require multiple network interfaces.</p>
    pub fn set_network_interface_count(mut self, input: ::std::option::Option<crate::types::NetworkInterfaceCountRequest>) -> Self {
        self.network_interface_count = input;
        self
    }
    /// <p>The minimum and maximum number of network interfaces for the instance types. This is useful for workloads that require multiple network interfaces.</p>
    pub fn get_network_interface_count(&self) -> &::std::option::Option<crate::types::NetworkInterfaceCountRequest> {
        &self.network_interface_count
    }
    /// <p>Indicates whether to include instance types with local storage. Set to <code>included</code> to allow local storage, <code>excluded</code> to exclude it, or <code>required</code> to use only instances with local storage.</p>
    pub fn local_storage(mut self, input: crate::types::LocalStorage) -> Self {
        self.local_storage = ::std::option::Option::Some(input);
        self
    }
    /// <p>Indicates whether to include instance types with local storage. Set to <code>included</code> to allow local storage, <code>excluded</code> to exclude it, or <code>required</code> to use only instances with local storage.</p>
    pub fn set_local_storage(mut self, input: ::std::option::Option<crate::types::LocalStorage>) -> Self {
        self.local_storage = input;
        self
    }
    /// <p>Indicates whether to include instance types with local storage. Set to <code>included</code> to allow local storage, <code>excluded</code> to exclude it, or <code>required</code> to use only instances with local storage.</p>
    pub fn get_local_storage(&self) -> &::std::option::Option<crate::types::LocalStorage> {
        &self.local_storage
    }
    /// Appends an item to `local_storage_types`.
    ///
    /// To override the contents of this collection use [`set_local_storage_types`](Self::set_local_storage_types).
    ///
    /// <p>The local storage types to include. You can specify <code>hdd</code> for hard disk drives, <code>ssd</code> for solid state drives, or both.</p>
    pub fn local_storage_types(mut self, input: crate::types::LocalStorageType) -> Self {
        let mut v = self.local_storage_types.unwrap_or_default();
        v.push(input);
        self.local_storage_types = ::std::option::Option::Some(v);
        self
    }
    /// <p>The local storage types to include. You can specify <code>hdd</code> for hard disk drives, <code>ssd</code> for solid state drives, or both.</p>
    pub fn set_local_storage_types(mut self, input: ::std::option::Option<::std::vec::Vec<crate::types::LocalStorageType>>) -> Self {
        self.local_storage_types = input;
        self
    }
    /// <p>The local storage types to include. You can specify <code>hdd</code> for hard disk drives, <code>ssd</code> for solid state drives, or both.</p>
    pub fn get_local_storage_types(&self) -> &::std::option::Option<::std::vec::Vec<crate::types::LocalStorageType>> {
        &self.local_storage_types
    }
    /// <p>The minimum and maximum total local storage in gigabytes (GB) for instance types with local storage.</p>
    pub fn total_local_storage_gb(mut self, input: crate::types::TotalLocalStorageGbRequest) -> Self {
        self.total_local_storage_gb = ::std::option::Option::Some(input);
        self
    }
    /// <p>The minimum and maximum total local storage in gigabytes (GB) for instance types with local storage.</p>
    pub fn set_total_local_storage_gb(mut self, input: ::std::option::Option<crate::types::TotalLocalStorageGbRequest>) -> Self {
        self.total_local_storage_gb = input;
        self
    }
    /// <p>The minimum and maximum total local storage in gigabytes (GB) for instance types with local storage.</p>
    pub fn get_total_local_storage_gb(&self) -> &::std::option::Option<crate::types::TotalLocalStorageGbRequest> {
        &self.total_local_storage_gb
    }
    /// <p>The minimum and maximum baseline Amazon EBS bandwidth in megabits per second (Mbps). This is important for workloads with high storage I/O requirements.</p>
    pub fn baseline_ebs_bandwidth_mbps(mut self, input: crate::types::BaselineEbsBandwidthMbpsRequest) -> Self {
        self.baseline_ebs_bandwidth_mbps = ::std::option::Option::Some(input);
        self
    }
    /// <p>The minimum and maximum baseline Amazon EBS bandwidth in megabits per second (Mbps). This is important for workloads with high storage I/O requirements.</p>
    pub fn set_baseline_ebs_bandwidth_mbps(mut self, input: ::std::option::Option<crate::types::BaselineEbsBandwidthMbpsRequest>) -> Self {
        self.baseline_ebs_bandwidth_mbps = input;
        self
    }
    /// <p>The minimum and maximum baseline Amazon EBS bandwidth in megabits per second (Mbps). This is important for workloads with high storage I/O requirements.</p>
    pub fn get_baseline_ebs_bandwidth_mbps(&self) -> &::std::option::Option<crate::types::BaselineEbsBandwidthMbpsRequest> {
        &self.baseline_ebs_bandwidth_mbps
    }
    /// Appends an item to `accelerator_types`.
    ///
    /// To override the contents of this collection use [`set_accelerator_types`](Self::set_accelerator_types).
    ///
    /// <p>The accelerator types to include. You can specify <code>gpu</code> for graphics processing units, <code>fpga</code> for field programmable gate arrays, or <code>inference</code> for machine learning inference accelerators.</p>
    pub fn accelerator_types(mut self, input: crate::types::AcceleratorType) -> Self {
        let mut v = self.accelerator_types.unwrap_or_default();
        v.push(input);
        self.accelerator_types = ::std::option::Option::Some(v);
        self
    }
    /// <p>The accelerator types to include. You can specify <code>gpu</code> for graphics processing units, <code>fpga</code> for field programmable gate arrays, or <code>inference</code> for machine learning inference accelerators.</p>
    pub fn set_accelerator_types(mut self, input: ::std::option::Option<::std::vec::Vec<crate::types::AcceleratorType>>) -> Self {
        self.accelerator_types = input;
        self
    }
    /// <p>The accelerator types to include. You can specify <code>gpu</code> for graphics processing units, <code>fpga</code> for field programmable gate arrays, or <code>inference</code> for machine learning inference accelerators.</p>
    pub fn get_accelerator_types(&self) -> &::std::option::Option<::std::vec::Vec<crate::types::AcceleratorType>> {
        &self.accelerator_types
    }
    /// <p>The minimum and maximum number of accelerators for the instance types. This is used when you need instances with specific numbers of GPUs or other accelerators.</p>
    pub fn accelerator_count(mut self, input: crate::types::AcceleratorCountRequest) -> Self {
        self.accelerator_count = ::std::option::Option::Some(input);
        self
    }
    /// <p>The minimum and maximum number of accelerators for the instance types. This is used when you need instances with specific numbers of GPUs or other accelerators.</p>
    pub fn set_accelerator_count(mut self, input: ::std::option::Option<crate::types::AcceleratorCountRequest>) -> Self {
        self.accelerator_count = input;
        self
    }
    /// <p>The minimum and maximum number of accelerators for the instance types. This is used when you need instances with specific numbers of GPUs or other accelerators.</p>
    pub fn get_accelerator_count(&self) -> &::std::option::Option<crate::types::AcceleratorCountRequest> {
        &self.accelerator_count
    }
    /// Appends an item to `accelerator_manufacturers`.
    ///
    /// To override the contents of this collection use [`set_accelerator_manufacturers`](Self::set_accelerator_manufacturers).
    ///
    /// <p>The accelerator manufacturers to include. You can specify <code>nvidia</code>, <code>amd</code>, <code>amazon-web-services</code>, or <code>xilinx</code> depending on your accelerator requirements.</p>
    pub fn accelerator_manufacturers(mut self, input: crate::types::AcceleratorManufacturer) -> Self {
        let mut v = self.accelerator_manufacturers.unwrap_or_default();
        v.push(input);
        self.accelerator_manufacturers = ::std::option::Option::Some(v);
        self
    }
    /// <p>The accelerator manufacturers to include. You can specify <code>nvidia</code>, <code>amd</code>, <code>amazon-web-services</code>, or <code>xilinx</code> depending on your accelerator requirements.</p>
    pub fn set_accelerator_manufacturers(mut self, input: ::std::option::Option<::std::vec::Vec<crate::types::AcceleratorManufacturer>>) -> Self {
        self.accelerator_manufacturers = input;
        self
    }
    /// <p>The accelerator manufacturers to include. You can specify <code>nvidia</code>, <code>amd</code>, <code>amazon-web-services</code>, or <code>xilinx</code> depending on your accelerator requirements.</p>
    pub fn get_accelerator_manufacturers(&self) -> &::std::option::Option<::std::vec::Vec<crate::types::AcceleratorManufacturer>> {
        &self.accelerator_manufacturers
    }
    /// Appends an item to `accelerator_names`.
    ///
    /// To override the contents of this collection use [`set_accelerator_names`](Self::set_accelerator_names).
    ///
    /// <p>The specific accelerator names to include. For example, you can specify <code>a100</code>, <code>v100</code>, <code>k80</code>, or other specific accelerator models.</p>
    pub fn accelerator_names(mut self, input: crate::types::AcceleratorName) -> Self {
        let mut v = self.accelerator_names.unwrap_or_default();
        v.push(input);
        self.accelerator_names = ::std::option::Option::Some(v);
        self
    }
    /// <p>The specific accelerator names to include. For example, you can specify <code>a100</code>, <code>v100</code>, <code>k80</code>, or other specific accelerator models.</p>
    pub fn set_accelerator_names(mut self, input: ::std::option::Option<::std::vec::Vec<crate::types::AcceleratorName>>) -> Self {
        self.accelerator_names = input;
        self
    }
    /// <p>The specific accelerator names to include. For example, you can specify <code>a100</code>, <code>v100</code>, <code>k80</code>, or other specific accelerator models.</p>
    pub fn get_accelerator_names(&self) -> &::std::option::Option<::std::vec::Vec<crate::types::AcceleratorName>> {
        &self.accelerator_names
    }
    /// <p>The minimum and maximum total accelerator memory in mebibytes (MiB). This is important for GPU workloads that require specific amounts of video memory.</p>
    pub fn accelerator_total_memory_mib(mut self, input: crate::types::AcceleratorTotalMemoryMiBRequest) -> Self {
        self.accelerator_total_memory_mib = ::std::option::Option::Some(input);
        self
    }
    /// <p>The minimum and maximum total accelerator memory in mebibytes (MiB). This is important for GPU workloads that require specific amounts of video memory.</p>
    pub fn set_accelerator_total_memory_mib(mut self, input: ::std::option::Option<crate::types::AcceleratorTotalMemoryMiBRequest>) -> Self {
        self.accelerator_total_memory_mib = input;
        self
    }
    /// <p>The minimum and maximum total accelerator memory in mebibytes (MiB). This is important for GPU workloads that require specific amounts of video memory.</p>
    pub fn get_accelerator_total_memory_mib(&self) -> &::std::option::Option<crate::types::AcceleratorTotalMemoryMiBRequest> {
        &self.accelerator_total_memory_mib
    }
    /// <p>The minimum and maximum network bandwidth in gigabits per second (Gbps). This is crucial for network-intensive workloads that require high throughput.</p>
    pub fn network_bandwidth_gbps(mut self, input: crate::types::NetworkBandwidthGbpsRequest) -> Self {
        self.network_bandwidth_gbps = ::std::option::Option::Some(input);
        self
    }
    /// <p>The minimum and maximum network bandwidth in gigabits per second (Gbps). This is crucial for network-intensive workloads that require high throughput.</p>
    pub fn set_network_bandwidth_gbps(mut self, input: ::std::option::Option<crate::types::NetworkBandwidthGbpsRequest>) -> Self {
        self.network_bandwidth_gbps = input;
        self
    }
    /// <p>The minimum and maximum network bandwidth in gigabits per second (Gbps). This is crucial for network-intensive workloads that require high throughput.</p>
    pub fn get_network_bandwidth_gbps(&self) -> &::std::option::Option<crate::types::NetworkBandwidthGbpsRequest> {
        &self.network_bandwidth_gbps
    }
    /// Appends an item to `allowed_instance_types`.
    ///
    /// To override the contents of this collection use [`set_allowed_instance_types`](Self::set_allowed_instance_types).
    ///
    /// <p>The instance types to include in the selection. When specified, Amazon ECS only considers these instance types, subject to the other requirements specified.</p>
    pub fn allowed_instance_types(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        let mut v = self.allowed_instance_types.unwrap_or_default();
        v.push(input.into());
        self.allowed_instance_types = ::std::option::Option::Some(v);
        self
    }
    /// <p>The instance types to include in the selection. When specified, Amazon ECS only considers these instance types, subject to the other requirements specified.</p>
    pub fn set_allowed_instance_types(mut self, input: ::std::option::Option<::std::vec::Vec<::std::string::String>>) -> Self {
        self.allowed_instance_types = input;
        self
    }
    /// <p>The instance types to include in the selection. When specified, Amazon ECS only considers these instance types, subject to the other requirements specified.</p>
    pub fn get_allowed_instance_types(&self) -> &::std::option::Option<::std::vec::Vec<::std::string::String>> {
        &self.allowed_instance_types
    }
    /// <p>The maximum price for Spot instances as a percentage of the optimal On-Demand price. This provides more precise cost control for Spot instance selection.</p>
    pub fn max_spot_price_as_percentage_of_optimal_on_demand_price(mut self, input: i32) -> Self {
        self.max_spot_price_as_percentage_of_optimal_on_demand_price = ::std::option::Option::Some(input);
        self
    }
    /// <p>The maximum price for Spot instances as a percentage of the optimal On-Demand price. This provides more precise cost control for Spot instance selection.</p>
    pub fn set_max_spot_price_as_percentage_of_optimal_on_demand_price(mut self, input: ::std::option::Option<i32>) -> Self {
        self.max_spot_price_as_percentage_of_optimal_on_demand_price = input;
        self
    }
    /// <p>The maximum price for Spot instances as a percentage of the optimal On-Demand price. This provides more precise cost control for Spot instance selection.</p>
    pub fn get_max_spot_price_as_percentage_of_optimal_on_demand_price(&self) -> &::std::option::Option<i32> {
        &self.max_spot_price_as_percentage_of_optimal_on_demand_price
    }
    /// Consumes the builder and constructs a [`InstanceRequirementsRequest`](crate::types::InstanceRequirementsRequest).
    pub fn build(self) -> crate::types::InstanceRequirementsRequest {
        crate::types::InstanceRequirementsRequest {
            v_cpu_count: self.v_cpu_count,
            memory_mib: self.memory_mib,
            cpu_manufacturers: self.cpu_manufacturers,
            memory_gib_per_v_cpu: self.memory_gib_per_v_cpu,
            excluded_instance_types: self.excluded_instance_types,
            instance_generations: self.instance_generations,
            spot_max_price_percentage_over_lowest_price: self.spot_max_price_percentage_over_lowest_price,
            on_demand_max_price_percentage_over_lowest_price: self.on_demand_max_price_percentage_over_lowest_price,
            bare_metal: self.bare_metal,
            burstable_performance: self.burstable_performance,
            require_hibernate_support: self.require_hibernate_support,
            network_interface_count: self.network_interface_count,
            local_storage: self.local_storage,
            local_storage_types: self.local_storage_types,
            total_local_storage_gb: self.total_local_storage_gb,
            baseline_ebs_bandwidth_mbps: self.baseline_ebs_bandwidth_mbps,
            accelerator_types: self.accelerator_types,
            accelerator_count: self.accelerator_count,
            accelerator_manufacturers: self.accelerator_manufacturers,
            accelerator_names: self.accelerator_names,
            accelerator_total_memory_mib: self.accelerator_total_memory_mib,
            network_bandwidth_gbps: self.network_bandwidth_gbps,
            allowed_instance_types: self.allowed_instance_types,
            max_spot_price_as_percentage_of_optimal_on_demand_price: self.max_spot_price_as_percentage_of_optimal_on_demand_price,
        }
    }
}
