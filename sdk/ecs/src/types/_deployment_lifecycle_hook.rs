// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.

/// <p>A deployment lifecycle hook runs custom logic at specific stages of the deployment process. Currently, you can use Lambda functions as hook targets.</p>
#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::fmt::Debug)]
pub struct DeploymentLifecycleHook {
    /// <p>The Amazon Resource Name (ARN) of the hook target. Currently, only Lambda function ARNs are supported.</p>
    /// <p>You must provide this parameter when configuring a deployment lifecycle hook.</p>
    pub hook_target_arn: ::std::option::Option<::std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the IAM role that grants Amazon ECS permission to call Lambda functions on your behalf.</p>
    /// <p>For more information, see <a href="https://docs.aws.amazon.com/AmazonECS/latest/developerguide/blue-green-permissions.html">Permissions required for Lambda functions in Amazon ECS blue/green deployments</a> in the<i> Amazon Elastic Container Service Developer Guide</i>.</p>
    pub role_arn: ::std::option::Option<::std::string::String>,
    /// <p>The lifecycle stages at which to run the hook. Choose from these valid values:</p>
    /// <ul>
    /// <li>
    /// <p>RECONCILE_SERVICE</p>
    /// <p>This stage only happens when you start a new service deployment with more than 1 service revision in an ACTIVE state.</p>
    /// <p>You can use a lifecycle hook for this stage.</p></li>
    /// <li>
    /// <p>PRE_SCALE_UP</p>
    /// <p>The green service revision has not started. The blue service revision is handling 100% of the production traffic. There is no test traffic.</p>
    /// <p>You can use a lifecycle hook for this stage.</p></li>
    /// <li>
    /// <p>SCALE_UP</p>
    /// <p>The time when the green service revision scales up to 100% and launches new tasks. The green service revision is not serving any traffic at this point.</p>
    /// <p>You can't use a lifecycle hook for this stage.</p></li>
    /// <li>
    /// <p>POST_SCALE_UP</p>
    /// <p>The green service revision has started. The blue service revision is handling 100% of the production traffic. There is no test traffic.</p>
    /// <p>You can use a lifecycle hook for this stage.</p></li>
    /// <li>
    /// <p>TEST_TRAFFIC_SHIFT</p>
    /// <p>The blue and green service revisions are running. The blue service revision handles 100% of the production traffic. The green service revision is migrating from 0% to 100% of test traffic.</p>
    /// <p>You can use a lifecycle hook for this stage.</p></li>
    /// <li>
    /// <p>POST_TEST_TRAFFIC_SHIFT</p>
    /// <p>The test traffic shift is complete. The green service revision handles 100% of the test traffic.</p>
    /// <p>You can use a lifecycle hook for this stage.</p></li>
    /// <li>
    /// <p>PRODUCTION_TRAFFIC_SHIFT</p>
    /// <p>Production traffic is shifting to the green service revision. The green service revision is migrating from 0% to 100% of production traffic.</p>
    /// <p>You can use a lifecycle hook for this stage.</p></li>
    /// <li>
    /// <p>POST_PRODUCTION_TRAFFIC_SHIFT</p>
    /// <p>The production traffic shift is complete.</p>
    /// <p>Yes</p></li>
    /// <li>
    /// <p>BAKE_TIME</p>
    /// <p>The duration when both blue and green service revisions are running simultaneously.</p>
    /// <p>You can't use a lifecycle hook for this stage.</p></li>
    /// <li>
    /// <p>CLEAN_UP</p>
    /// <p>The blue service revision has completely scaled down to 0 running tasks. The green service revision is now the production service revision after this stage.</p>
    /// <p>You can't use a lifecycle hook for this stage.</p></li>
    /// </ul>
    /// <p>You must provide this parameter when configuring a deployment lifecycle hook.</p>
    pub lifecycle_stages: ::std::option::Option<::std::vec::Vec<crate::types::DeploymentLifecycleHookStage>>,
    /// <p>Optionally provide details about the hook. Use this field to pass custom parameters to your hook target (such as a Lambda function).</p>
    pub hook_details: ::std::option::Option<::aws_smithy_types::Document>,
}
impl DeploymentLifecycleHook {
    /// <p>The Amazon Resource Name (ARN) of the hook target. Currently, only Lambda function ARNs are supported.</p>
    /// <p>You must provide this parameter when configuring a deployment lifecycle hook.</p>
    pub fn hook_target_arn(&self) -> ::std::option::Option<&str> {
        self.hook_target_arn.as_deref()
    }
    /// <p>The Amazon Resource Name (ARN) of the IAM role that grants Amazon ECS permission to call Lambda functions on your behalf.</p>
    /// <p>For more information, see <a href="https://docs.aws.amazon.com/AmazonECS/latest/developerguide/blue-green-permissions.html">Permissions required for Lambda functions in Amazon ECS blue/green deployments</a> in the<i> Amazon Elastic Container Service Developer Guide</i>.</p>
    pub fn role_arn(&self) -> ::std::option::Option<&str> {
        self.role_arn.as_deref()
    }
    /// <p>The lifecycle stages at which to run the hook. Choose from these valid values:</p>
    /// <ul>
    /// <li>
    /// <p>RECONCILE_SERVICE</p>
    /// <p>This stage only happens when you start a new service deployment with more than 1 service revision in an ACTIVE state.</p>
    /// <p>You can use a lifecycle hook for this stage.</p></li>
    /// <li>
    /// <p>PRE_SCALE_UP</p>
    /// <p>The green service revision has not started. The blue service revision is handling 100% of the production traffic. There is no test traffic.</p>
    /// <p>You can use a lifecycle hook for this stage.</p></li>
    /// <li>
    /// <p>SCALE_UP</p>
    /// <p>The time when the green service revision scales up to 100% and launches new tasks. The green service revision is not serving any traffic at this point.</p>
    /// <p>You can't use a lifecycle hook for this stage.</p></li>
    /// <li>
    /// <p>POST_SCALE_UP</p>
    /// <p>The green service revision has started. The blue service revision is handling 100% of the production traffic. There is no test traffic.</p>
    /// <p>You can use a lifecycle hook for this stage.</p></li>
    /// <li>
    /// <p>TEST_TRAFFIC_SHIFT</p>
    /// <p>The blue and green service revisions are running. The blue service revision handles 100% of the production traffic. The green service revision is migrating from 0% to 100% of test traffic.</p>
    /// <p>You can use a lifecycle hook for this stage.</p></li>
    /// <li>
    /// <p>POST_TEST_TRAFFIC_SHIFT</p>
    /// <p>The test traffic shift is complete. The green service revision handles 100% of the test traffic.</p>
    /// <p>You can use a lifecycle hook for this stage.</p></li>
    /// <li>
    /// <p>PRODUCTION_TRAFFIC_SHIFT</p>
    /// <p>Production traffic is shifting to the green service revision. The green service revision is migrating from 0% to 100% of production traffic.</p>
    /// <p>You can use a lifecycle hook for this stage.</p></li>
    /// <li>
    /// <p>POST_PRODUCTION_TRAFFIC_SHIFT</p>
    /// <p>The production traffic shift is complete.</p>
    /// <p>Yes</p></li>
    /// <li>
    /// <p>BAKE_TIME</p>
    /// <p>The duration when both blue and green service revisions are running simultaneously.</p>
    /// <p>You can't use a lifecycle hook for this stage.</p></li>
    /// <li>
    /// <p>CLEAN_UP</p>
    /// <p>The blue service revision has completely scaled down to 0 running tasks. The green service revision is now the production service revision after this stage.</p>
    /// <p>You can't use a lifecycle hook for this stage.</p></li>
    /// </ul>
    /// <p>You must provide this parameter when configuring a deployment lifecycle hook.</p>
    ///
    /// If no value was sent for this field, a default will be set. If you want to determine if no value was sent, use `.lifecycle_stages.is_none()`.
    pub fn lifecycle_stages(&self) -> &[crate::types::DeploymentLifecycleHookStage] {
        self.lifecycle_stages.as_deref().unwrap_or_default()
    }
    /// <p>Optionally provide details about the hook. Use this field to pass custom parameters to your hook target (such as a Lambda function).</p>
    pub fn hook_details(&self) -> ::std::option::Option<&::aws_smithy_types::Document> {
        self.hook_details.as_ref()
    }
}
impl DeploymentLifecycleHook {
    /// Creates a new builder-style object to manufacture [`DeploymentLifecycleHook`](crate::types::DeploymentLifecycleHook).
    pub fn builder() -> crate::types::builders::DeploymentLifecycleHookBuilder {
        crate::types::builders::DeploymentLifecycleHookBuilder::default()
    }
}

/// A builder for [`DeploymentLifecycleHook`](crate::types::DeploymentLifecycleHook).
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::default::Default, ::std::fmt::Debug)]
#[non_exhaustive]
pub struct DeploymentLifecycleHookBuilder {
    pub(crate) hook_target_arn: ::std::option::Option<::std::string::String>,
    pub(crate) role_arn: ::std::option::Option<::std::string::String>,
    pub(crate) lifecycle_stages: ::std::option::Option<::std::vec::Vec<crate::types::DeploymentLifecycleHookStage>>,
    pub(crate) hook_details: ::std::option::Option<::aws_smithy_types::Document>,
}
impl DeploymentLifecycleHookBuilder {
    /// <p>The Amazon Resource Name (ARN) of the hook target. Currently, only Lambda function ARNs are supported.</p>
    /// <p>You must provide this parameter when configuring a deployment lifecycle hook.</p>
    pub fn hook_target_arn(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.hook_target_arn = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The Amazon Resource Name (ARN) of the hook target. Currently, only Lambda function ARNs are supported.</p>
    /// <p>You must provide this parameter when configuring a deployment lifecycle hook.</p>
    pub fn set_hook_target_arn(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.hook_target_arn = input;
        self
    }
    /// <p>The Amazon Resource Name (ARN) of the hook target. Currently, only Lambda function ARNs are supported.</p>
    /// <p>You must provide this parameter when configuring a deployment lifecycle hook.</p>
    pub fn get_hook_target_arn(&self) -> &::std::option::Option<::std::string::String> {
        &self.hook_target_arn
    }
    /// <p>The Amazon Resource Name (ARN) of the IAM role that grants Amazon ECS permission to call Lambda functions on your behalf.</p>
    /// <p>For more information, see <a href="https://docs.aws.amazon.com/AmazonECS/latest/developerguide/blue-green-permissions.html">Permissions required for Lambda functions in Amazon ECS blue/green deployments</a> in the<i> Amazon Elastic Container Service Developer Guide</i>.</p>
    pub fn role_arn(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.role_arn = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The Amazon Resource Name (ARN) of the IAM role that grants Amazon ECS permission to call Lambda functions on your behalf.</p>
    /// <p>For more information, see <a href="https://docs.aws.amazon.com/AmazonECS/latest/developerguide/blue-green-permissions.html">Permissions required for Lambda functions in Amazon ECS blue/green deployments</a> in the<i> Amazon Elastic Container Service Developer Guide</i>.</p>
    pub fn set_role_arn(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.role_arn = input;
        self
    }
    /// <p>The Amazon Resource Name (ARN) of the IAM role that grants Amazon ECS permission to call Lambda functions on your behalf.</p>
    /// <p>For more information, see <a href="https://docs.aws.amazon.com/AmazonECS/latest/developerguide/blue-green-permissions.html">Permissions required for Lambda functions in Amazon ECS blue/green deployments</a> in the<i> Amazon Elastic Container Service Developer Guide</i>.</p>
    pub fn get_role_arn(&self) -> &::std::option::Option<::std::string::String> {
        &self.role_arn
    }
    /// Appends an item to `lifecycle_stages`.
    ///
    /// To override the contents of this collection use [`set_lifecycle_stages`](Self::set_lifecycle_stages).
    ///
    /// <p>The lifecycle stages at which to run the hook. Choose from these valid values:</p>
    /// <ul>
    /// <li>
    /// <p>RECONCILE_SERVICE</p>
    /// <p>This stage only happens when you start a new service deployment with more than 1 service revision in an ACTIVE state.</p>
    /// <p>You can use a lifecycle hook for this stage.</p></li>
    /// <li>
    /// <p>PRE_SCALE_UP</p>
    /// <p>The green service revision has not started. The blue service revision is handling 100% of the production traffic. There is no test traffic.</p>
    /// <p>You can use a lifecycle hook for this stage.</p></li>
    /// <li>
    /// <p>SCALE_UP</p>
    /// <p>The time when the green service revision scales up to 100% and launches new tasks. The green service revision is not serving any traffic at this point.</p>
    /// <p>You can't use a lifecycle hook for this stage.</p></li>
    /// <li>
    /// <p>POST_SCALE_UP</p>
    /// <p>The green service revision has started. The blue service revision is handling 100% of the production traffic. There is no test traffic.</p>
    /// <p>You can use a lifecycle hook for this stage.</p></li>
    /// <li>
    /// <p>TEST_TRAFFIC_SHIFT</p>
    /// <p>The blue and green service revisions are running. The blue service revision handles 100% of the production traffic. The green service revision is migrating from 0% to 100% of test traffic.</p>
    /// <p>You can use a lifecycle hook for this stage.</p></li>
    /// <li>
    /// <p>POST_TEST_TRAFFIC_SHIFT</p>
    /// <p>The test traffic shift is complete. The green service revision handles 100% of the test traffic.</p>
    /// <p>You can use a lifecycle hook for this stage.</p></li>
    /// <li>
    /// <p>PRODUCTION_TRAFFIC_SHIFT</p>
    /// <p>Production traffic is shifting to the green service revision. The green service revision is migrating from 0% to 100% of production traffic.</p>
    /// <p>You can use a lifecycle hook for this stage.</p></li>
    /// <li>
    /// <p>POST_PRODUCTION_TRAFFIC_SHIFT</p>
    /// <p>The production traffic shift is complete.</p>
    /// <p>Yes</p></li>
    /// <li>
    /// <p>BAKE_TIME</p>
    /// <p>The duration when both blue and green service revisions are running simultaneously.</p>
    /// <p>You can't use a lifecycle hook for this stage.</p></li>
    /// <li>
    /// <p>CLEAN_UP</p>
    /// <p>The blue service revision has completely scaled down to 0 running tasks. The green service revision is now the production service revision after this stage.</p>
    /// <p>You can't use a lifecycle hook for this stage.</p></li>
    /// </ul>
    /// <p>You must provide this parameter when configuring a deployment lifecycle hook.</p>
    pub fn lifecycle_stages(mut self, input: crate::types::DeploymentLifecycleHookStage) -> Self {
        let mut v = self.lifecycle_stages.unwrap_or_default();
        v.push(input);
        self.lifecycle_stages = ::std::option::Option::Some(v);
        self
    }
    /// <p>The lifecycle stages at which to run the hook. Choose from these valid values:</p>
    /// <ul>
    /// <li>
    /// <p>RECONCILE_SERVICE</p>
    /// <p>This stage only happens when you start a new service deployment with more than 1 service revision in an ACTIVE state.</p>
    /// <p>You can use a lifecycle hook for this stage.</p></li>
    /// <li>
    /// <p>PRE_SCALE_UP</p>
    /// <p>The green service revision has not started. The blue service revision is handling 100% of the production traffic. There is no test traffic.</p>
    /// <p>You can use a lifecycle hook for this stage.</p></li>
    /// <li>
    /// <p>SCALE_UP</p>
    /// <p>The time when the green service revision scales up to 100% and launches new tasks. The green service revision is not serving any traffic at this point.</p>
    /// <p>You can't use a lifecycle hook for this stage.</p></li>
    /// <li>
    /// <p>POST_SCALE_UP</p>
    /// <p>The green service revision has started. The blue service revision is handling 100% of the production traffic. There is no test traffic.</p>
    /// <p>You can use a lifecycle hook for this stage.</p></li>
    /// <li>
    /// <p>TEST_TRAFFIC_SHIFT</p>
    /// <p>The blue and green service revisions are running. The blue service revision handles 100% of the production traffic. The green service revision is migrating from 0% to 100% of test traffic.</p>
    /// <p>You can use a lifecycle hook for this stage.</p></li>
    /// <li>
    /// <p>POST_TEST_TRAFFIC_SHIFT</p>
    /// <p>The test traffic shift is complete. The green service revision handles 100% of the test traffic.</p>
    /// <p>You can use a lifecycle hook for this stage.</p></li>
    /// <li>
    /// <p>PRODUCTION_TRAFFIC_SHIFT</p>
    /// <p>Production traffic is shifting to the green service revision. The green service revision is migrating from 0% to 100% of production traffic.</p>
    /// <p>You can use a lifecycle hook for this stage.</p></li>
    /// <li>
    /// <p>POST_PRODUCTION_TRAFFIC_SHIFT</p>
    /// <p>The production traffic shift is complete.</p>
    /// <p>Yes</p></li>
    /// <li>
    /// <p>BAKE_TIME</p>
    /// <p>The duration when both blue and green service revisions are running simultaneously.</p>
    /// <p>You can't use a lifecycle hook for this stage.</p></li>
    /// <li>
    /// <p>CLEAN_UP</p>
    /// <p>The blue service revision has completely scaled down to 0 running tasks. The green service revision is now the production service revision after this stage.</p>
    /// <p>You can't use a lifecycle hook for this stage.</p></li>
    /// </ul>
    /// <p>You must provide this parameter when configuring a deployment lifecycle hook.</p>
    pub fn set_lifecycle_stages(mut self, input: ::std::option::Option<::std::vec::Vec<crate::types::DeploymentLifecycleHookStage>>) -> Self {
        self.lifecycle_stages = input;
        self
    }
    /// <p>The lifecycle stages at which to run the hook. Choose from these valid values:</p>
    /// <ul>
    /// <li>
    /// <p>RECONCILE_SERVICE</p>
    /// <p>This stage only happens when you start a new service deployment with more than 1 service revision in an ACTIVE state.</p>
    /// <p>You can use a lifecycle hook for this stage.</p></li>
    /// <li>
    /// <p>PRE_SCALE_UP</p>
    /// <p>The green service revision has not started. The blue service revision is handling 100% of the production traffic. There is no test traffic.</p>
    /// <p>You can use a lifecycle hook for this stage.</p></li>
    /// <li>
    /// <p>SCALE_UP</p>
    /// <p>The time when the green service revision scales up to 100% and launches new tasks. The green service revision is not serving any traffic at this point.</p>
    /// <p>You can't use a lifecycle hook for this stage.</p></li>
    /// <li>
    /// <p>POST_SCALE_UP</p>
    /// <p>The green service revision has started. The blue service revision is handling 100% of the production traffic. There is no test traffic.</p>
    /// <p>You can use a lifecycle hook for this stage.</p></li>
    /// <li>
    /// <p>TEST_TRAFFIC_SHIFT</p>
    /// <p>The blue and green service revisions are running. The blue service revision handles 100% of the production traffic. The green service revision is migrating from 0% to 100% of test traffic.</p>
    /// <p>You can use a lifecycle hook for this stage.</p></li>
    /// <li>
    /// <p>POST_TEST_TRAFFIC_SHIFT</p>
    /// <p>The test traffic shift is complete. The green service revision handles 100% of the test traffic.</p>
    /// <p>You can use a lifecycle hook for this stage.</p></li>
    /// <li>
    /// <p>PRODUCTION_TRAFFIC_SHIFT</p>
    /// <p>Production traffic is shifting to the green service revision. The green service revision is migrating from 0% to 100% of production traffic.</p>
    /// <p>You can use a lifecycle hook for this stage.</p></li>
    /// <li>
    /// <p>POST_PRODUCTION_TRAFFIC_SHIFT</p>
    /// <p>The production traffic shift is complete.</p>
    /// <p>Yes</p></li>
    /// <li>
    /// <p>BAKE_TIME</p>
    /// <p>The duration when both blue and green service revisions are running simultaneously.</p>
    /// <p>You can't use a lifecycle hook for this stage.</p></li>
    /// <li>
    /// <p>CLEAN_UP</p>
    /// <p>The blue service revision has completely scaled down to 0 running tasks. The green service revision is now the production service revision after this stage.</p>
    /// <p>You can't use a lifecycle hook for this stage.</p></li>
    /// </ul>
    /// <p>You must provide this parameter when configuring a deployment lifecycle hook.</p>
    pub fn get_lifecycle_stages(&self) -> &::std::option::Option<::std::vec::Vec<crate::types::DeploymentLifecycleHookStage>> {
        &self.lifecycle_stages
    }
    /// <p>Optionally provide details about the hook. Use this field to pass custom parameters to your hook target (such as a Lambda function).</p>
    pub fn hook_details(mut self, input: ::aws_smithy_types::Document) -> Self {
        self.hook_details = ::std::option::Option::Some(input);
        self
    }
    /// <p>Optionally provide details about the hook. Use this field to pass custom parameters to your hook target (such as a Lambda function).</p>
    pub fn set_hook_details(mut self, input: ::std::option::Option<::aws_smithy_types::Document>) -> Self {
        self.hook_details = input;
        self
    }
    /// <p>Optionally provide details about the hook. Use this field to pass custom parameters to your hook target (such as a Lambda function).</p>
    pub fn get_hook_details(&self) -> &::std::option::Option<::aws_smithy_types::Document> {
        &self.hook_details
    }
    /// Consumes the builder and constructs a [`DeploymentLifecycleHook`](crate::types::DeploymentLifecycleHook).
    pub fn build(self) -> crate::types::DeploymentLifecycleHook {
        crate::types::DeploymentLifecycleHook {
            hook_target_arn: self.hook_target_arn,
            role_arn: self.role_arn,
            lifecycle_stages: self.lifecycle_stages,
            hook_details: self.hook_details,
        }
    }
}
