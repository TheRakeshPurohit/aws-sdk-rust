// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
pub use crate::operation::autocomplete::_autocomplete_output::AutocompleteOutputBuilder;

pub use crate::operation::autocomplete::_autocomplete_input::AutocompleteInputBuilder;

impl crate::operation::autocomplete::builders::AutocompleteInputBuilder {
    /// Sends a request with this input using the given client.
    pub async fn send_with(
        self,
        client: &crate::Client,
    ) -> ::std::result::Result<
        crate::operation::autocomplete::AutocompleteOutput,
        ::aws_smithy_runtime_api::client::result::SdkError<
            crate::operation::autocomplete::AutocompleteError,
            ::aws_smithy_runtime_api::client::orchestrator::HttpResponse,
        >,
    > {
        let mut fluent_builder = client.autocomplete();
        fluent_builder.inner = self;
        fluent_builder.send().await
    }
}
/// Fluent builder constructing a request to `Autocomplete`.
///
/// <p><code>Autocomplete</code> completes potential places and addresses as the user types, based on the partial input. The API enhances the efficiency and accuracy of address by completing query based on a few entered keystrokes. It helps you by completing partial queries with valid address completion. Also, the API supports the filtering of results based on geographic location, country, or specific place types, and can be tailored using optional parameters like language and political views.</p>
#[derive(::std::clone::Clone, ::std::fmt::Debug)]
pub struct AutocompleteFluentBuilder {
    handle: ::std::sync::Arc<crate::client::Handle>,
    inner: crate::operation::autocomplete::builders::AutocompleteInputBuilder,
    config_override: ::std::option::Option<crate::config::Builder>,
}
impl
    crate::client::customize::internal::CustomizableSend<
        crate::operation::autocomplete::AutocompleteOutput,
        crate::operation::autocomplete::AutocompleteError,
    > for AutocompleteFluentBuilder
{
    fn send(
        self,
        config_override: crate::config::Builder,
    ) -> crate::client::customize::internal::BoxFuture<
        crate::client::customize::internal::SendResult<
            crate::operation::autocomplete::AutocompleteOutput,
            crate::operation::autocomplete::AutocompleteError,
        >,
    > {
        ::std::boxed::Box::pin(async move { self.config_override(config_override).send().await })
    }
}
impl AutocompleteFluentBuilder {
    /// Creates a new `AutocompleteFluentBuilder`.
    pub(crate) fn new(handle: ::std::sync::Arc<crate::client::Handle>) -> Self {
        Self {
            handle,
            inner: ::std::default::Default::default(),
            config_override: ::std::option::Option::None,
        }
    }
    /// Access the Autocomplete as a reference.
    pub fn as_input(&self) -> &crate::operation::autocomplete::builders::AutocompleteInputBuilder {
        &self.inner
    }
    /// Sends the request and returns the response.
    ///
    /// If an error occurs, an `SdkError` will be returned with additional details that
    /// can be matched against.
    ///
    /// By default, any retryable failures will be retried twice. Retry behavior
    /// is configurable with the [RetryConfig](aws_smithy_types::retry::RetryConfig), which can be
    /// set when configuring the client.
    pub async fn send(
        self,
    ) -> ::std::result::Result<
        crate::operation::autocomplete::AutocompleteOutput,
        ::aws_smithy_runtime_api::client::result::SdkError<
            crate::operation::autocomplete::AutocompleteError,
            ::aws_smithy_runtime_api::client::orchestrator::HttpResponse,
        >,
    > {
        let input = self
            .inner
            .build()
            .map_err(::aws_smithy_runtime_api::client::result::SdkError::construction_failure)?;
        let runtime_plugins = crate::operation::autocomplete::Autocomplete::operation_runtime_plugins(
            self.handle.runtime_plugins.clone(),
            &self.handle.conf,
            self.config_override,
        );
        crate::operation::autocomplete::Autocomplete::orchestrate(&runtime_plugins, input).await
    }

    /// Consumes this builder, creating a customizable operation that can be modified before being sent.
    pub fn customize(
        self,
    ) -> crate::client::customize::CustomizableOperation<
        crate::operation::autocomplete::AutocompleteOutput,
        crate::operation::autocomplete::AutocompleteError,
        Self,
    > {
        crate::client::customize::CustomizableOperation::new(self)
    }
    pub(crate) fn config_override(mut self, config_override: impl ::std::convert::Into<crate::config::Builder>) -> Self {
        self.set_config_override(::std::option::Option::Some(config_override.into()));
        self
    }

    pub(crate) fn set_config_override(&mut self, config_override: ::std::option::Option<crate::config::Builder>) -> &mut Self {
        self.config_override = config_override;
        self
    }
    /// <p>The free-form text query to match addresses against. This is usually a partially typed address from an end user in an address box or form.</p><note>
    /// <p>The fields <code>QueryText</code>, and <code>QueryID</code> are mutually exclusive.</p>
    /// </note>
    pub fn query_text(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.inner = self.inner.query_text(input.into());
        self
    }
    /// <p>The free-form text query to match addresses against. This is usually a partially typed address from an end user in an address box or form.</p><note>
    /// <p>The fields <code>QueryText</code>, and <code>QueryID</code> are mutually exclusive.</p>
    /// </note>
    pub fn set_query_text(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.inner = self.inner.set_query_text(input);
        self
    }
    /// <p>The free-form text query to match addresses against. This is usually a partially typed address from an end user in an address box or form.</p><note>
    /// <p>The fields <code>QueryText</code>, and <code>QueryID</code> are mutually exclusive.</p>
    /// </note>
    pub fn get_query_text(&self) -> &::std::option::Option<::std::string::String> {
        self.inner.get_query_text()
    }
    /// <p>An optional limit for the number of results returned in a single call.</p>
    pub fn max_results(mut self, input: i32) -> Self {
        self.inner = self.inner.max_results(input);
        self
    }
    /// <p>An optional limit for the number of results returned in a single call.</p>
    pub fn set_max_results(mut self, input: ::std::option::Option<i32>) -> Self {
        self.inner = self.inner.set_max_results(input);
        self
    }
    /// <p>An optional limit for the number of results returned in a single call.</p>
    pub fn get_max_results(&self) -> &::std::option::Option<i32> {
        self.inner.get_max_results()
    }
    ///
    /// Appends an item to `BiasPosition`.
    ///
    /// To override the contents of this collection use [`set_bias_position`](Self::set_bias_position).
    ///
    /// <p>The position in longitude and latitude that the results should be close to. Typically, place results returned are ranked higher the closer they are to this position. Stored in <code>\[lng, lat\]</code> and in the WSG84 format.</p><note>
    /// <p>The fields <code>BiasPosition</code>, <code>FilterBoundingBox</code>, and <code>FilterCircle</code> are mutually exclusive.</p>
    /// </note>
    pub fn bias_position(mut self, input: f64) -> Self {
        self.inner = self.inner.bias_position(input);
        self
    }
    /// <p>The position in longitude and latitude that the results should be close to. Typically, place results returned are ranked higher the closer they are to this position. Stored in <code>\[lng, lat\]</code> and in the WSG84 format.</p><note>
    /// <p>The fields <code>BiasPosition</code>, <code>FilterBoundingBox</code>, and <code>FilterCircle</code> are mutually exclusive.</p>
    /// </note>
    pub fn set_bias_position(mut self, input: ::std::option::Option<::std::vec::Vec<f64>>) -> Self {
        self.inner = self.inner.set_bias_position(input);
        self
    }
    /// <p>The position in longitude and latitude that the results should be close to. Typically, place results returned are ranked higher the closer they are to this position. Stored in <code>\[lng, lat\]</code> and in the WSG84 format.</p><note>
    /// <p>The fields <code>BiasPosition</code>, <code>FilterBoundingBox</code>, and <code>FilterCircle</code> are mutually exclusive.</p>
    /// </note>
    pub fn get_bias_position(&self) -> &::std::option::Option<::std::vec::Vec<f64>> {
        self.inner.get_bias_position()
    }
    /// <p>A structure which contains a set of inclusion/exclusion properties that results must possess in order to be returned as a result.</p>
    pub fn filter(mut self, input: crate::types::AutocompleteFilter) -> Self {
        self.inner = self.inner.filter(input);
        self
    }
    /// <p>A structure which contains a set of inclusion/exclusion properties that results must possess in order to be returned as a result.</p>
    pub fn set_filter(mut self, input: ::std::option::Option<crate::types::AutocompleteFilter>) -> Self {
        self.inner = self.inner.set_filter(input);
        self
    }
    /// <p>A structure which contains a set of inclusion/exclusion properties that results must possess in order to be returned as a result.</p>
    pub fn get_filter(&self) -> &::std::option::Option<crate::types::AutocompleteFilter> {
        self.inner.get_filter()
    }
    /// <p>The <code>PostalCodeMode</code> affects how postal code results are returned. If a postal code spans multiple localities and this value is empty, partial district or locality information may be returned under a single postal code result entry. If it's populated with the value <code>EnumerateSpannedLocalities</code>, all cities in that postal code are returned.</p>
    pub fn postal_code_mode(mut self, input: crate::types::PostalCodeMode) -> Self {
        self.inner = self.inner.postal_code_mode(input);
        self
    }
    /// <p>The <code>PostalCodeMode</code> affects how postal code results are returned. If a postal code spans multiple localities and this value is empty, partial district or locality information may be returned under a single postal code result entry. If it's populated with the value <code>EnumerateSpannedLocalities</code>, all cities in that postal code are returned.</p>
    pub fn set_postal_code_mode(mut self, input: ::std::option::Option<crate::types::PostalCodeMode>) -> Self {
        self.inner = self.inner.set_postal_code_mode(input);
        self
    }
    /// <p>The <code>PostalCodeMode</code> affects how postal code results are returned. If a postal code spans multiple localities and this value is empty, partial district or locality information may be returned under a single postal code result entry. If it's populated with the value <code>EnumerateSpannedLocalities</code>, all cities in that postal code are returned.</p>
    pub fn get_postal_code_mode(&self) -> &::std::option::Option<crate::types::PostalCodeMode> {
        self.inner.get_postal_code_mode()
    }
    ///
    /// Appends an item to `AdditionalFeatures`.
    ///
    /// To override the contents of this collection use [`set_additional_features`](Self::set_additional_features).
    ///
    /// <p>A list of optional additional parameters that can be requested for each result.</p>
    pub fn additional_features(mut self, input: crate::types::AutocompleteAdditionalFeature) -> Self {
        self.inner = self.inner.additional_features(input);
        self
    }
    /// <p>A list of optional additional parameters that can be requested for each result.</p>
    pub fn set_additional_features(mut self, input: ::std::option::Option<::std::vec::Vec<crate::types::AutocompleteAdditionalFeature>>) -> Self {
        self.inner = self.inner.set_additional_features(input);
        self
    }
    /// <p>A list of optional additional parameters that can be requested for each result.</p>
    pub fn get_additional_features(&self) -> &::std::option::Option<::std::vec::Vec<crate::types::AutocompleteAdditionalFeature>> {
        self.inner.get_additional_features()
    }
    /// <p>A list of <a href="https://en.wikipedia.org/wiki/IETF_language_tag">BCP 47</a> compliant language codes for the results to be rendered in. If there is no data for the result in the requested language, data will be returned in the default language for the entry.</p>
    pub fn language(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.inner = self.inner.language(input.into());
        self
    }
    /// <p>A list of <a href="https://en.wikipedia.org/wiki/IETF_language_tag">BCP 47</a> compliant language codes for the results to be rendered in. If there is no data for the result in the requested language, data will be returned in the default language for the entry.</p>
    pub fn set_language(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.inner = self.inner.set_language(input);
        self
    }
    /// <p>A list of <a href="https://en.wikipedia.org/wiki/IETF_language_tag">BCP 47</a> compliant language codes for the results to be rendered in. If there is no data for the result in the requested language, data will be returned in the default language for the entry.</p>
    pub fn get_language(&self) -> &::std::option::Option<::std::string::String> {
        self.inner.get_language()
    }
    /// <p>The alpha-2 or alpha-3 character code for the political view of a country. The political view applies to the results of the request to represent unresolved territorial claims through the point of view of the specified country.</p>
    /// <p>The following political views are currently supported:</p>
    /// <ul>
    /// <li>
    /// <p><code>ARG</code>: Argentina's view on the Southern Patagonian Ice Field and Tierra Del Fuego, including the Falkland Islands, South Georgia, and South Sandwich Islands</p></li>
    /// <li>
    /// <p><code>EGY</code>: Egypt's view on Bir Tawil</p></li>
    /// <li>
    /// <p><code>IND</code>: India's view on Gilgit-Baltistan</p></li>
    /// <li>
    /// <p><code>KEN</code>: Kenya's view on the Ilemi Triangle</p></li>
    /// <li>
    /// <p><code>MAR</code>: Morocco's view on Western Sahara</p></li>
    /// <li>
    /// <p><code>RUS</code>: Russia's view on Crimea</p></li>
    /// <li>
    /// <p><code>SDN</code>: Sudan's view on the Halaib Triangle</p></li>
    /// <li>
    /// <p><code>SRB</code>: Serbia's view on Kosovo, Vukovar, and Sarengrad Islands</p></li>
    /// <li>
    /// <p><code>SUR</code>: Suriname's view on the Courantyne Headwaters and Lawa Headwaters</p></li>
    /// <li>
    /// <p><code>SYR</code>: Syria's view on the Golan Heights</p></li>
    /// <li>
    /// <p><code>TUR</code>: Turkey's view on Cyprus and Northern Cyprus</p></li>
    /// <li>
    /// <p><code>TZA</code>: Tanzania's view on Lake Malawi</p></li>
    /// <li>
    /// <p><code>URY</code>: Uruguay's view on Rincon de Artigas</p></li>
    /// <li>
    /// <p><code>VNM</code>: Vietnam's view on the Paracel Islands and Spratly Islands</p></li>
    /// </ul>
    pub fn political_view(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.inner = self.inner.political_view(input.into());
        self
    }
    /// <p>The alpha-2 or alpha-3 character code for the political view of a country. The political view applies to the results of the request to represent unresolved territorial claims through the point of view of the specified country.</p>
    /// <p>The following political views are currently supported:</p>
    /// <ul>
    /// <li>
    /// <p><code>ARG</code>: Argentina's view on the Southern Patagonian Ice Field and Tierra Del Fuego, including the Falkland Islands, South Georgia, and South Sandwich Islands</p></li>
    /// <li>
    /// <p><code>EGY</code>: Egypt's view on Bir Tawil</p></li>
    /// <li>
    /// <p><code>IND</code>: India's view on Gilgit-Baltistan</p></li>
    /// <li>
    /// <p><code>KEN</code>: Kenya's view on the Ilemi Triangle</p></li>
    /// <li>
    /// <p><code>MAR</code>: Morocco's view on Western Sahara</p></li>
    /// <li>
    /// <p><code>RUS</code>: Russia's view on Crimea</p></li>
    /// <li>
    /// <p><code>SDN</code>: Sudan's view on the Halaib Triangle</p></li>
    /// <li>
    /// <p><code>SRB</code>: Serbia's view on Kosovo, Vukovar, and Sarengrad Islands</p></li>
    /// <li>
    /// <p><code>SUR</code>: Suriname's view on the Courantyne Headwaters and Lawa Headwaters</p></li>
    /// <li>
    /// <p><code>SYR</code>: Syria's view on the Golan Heights</p></li>
    /// <li>
    /// <p><code>TUR</code>: Turkey's view on Cyprus and Northern Cyprus</p></li>
    /// <li>
    /// <p><code>TZA</code>: Tanzania's view on Lake Malawi</p></li>
    /// <li>
    /// <p><code>URY</code>: Uruguay's view on Rincon de Artigas</p></li>
    /// <li>
    /// <p><code>VNM</code>: Vietnam's view on the Paracel Islands and Spratly Islands</p></li>
    /// </ul>
    pub fn set_political_view(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.inner = self.inner.set_political_view(input);
        self
    }
    /// <p>The alpha-2 or alpha-3 character code for the political view of a country. The political view applies to the results of the request to represent unresolved territorial claims through the point of view of the specified country.</p>
    /// <p>The following political views are currently supported:</p>
    /// <ul>
    /// <li>
    /// <p><code>ARG</code>: Argentina's view on the Southern Patagonian Ice Field and Tierra Del Fuego, including the Falkland Islands, South Georgia, and South Sandwich Islands</p></li>
    /// <li>
    /// <p><code>EGY</code>: Egypt's view on Bir Tawil</p></li>
    /// <li>
    /// <p><code>IND</code>: India's view on Gilgit-Baltistan</p></li>
    /// <li>
    /// <p><code>KEN</code>: Kenya's view on the Ilemi Triangle</p></li>
    /// <li>
    /// <p><code>MAR</code>: Morocco's view on Western Sahara</p></li>
    /// <li>
    /// <p><code>RUS</code>: Russia's view on Crimea</p></li>
    /// <li>
    /// <p><code>SDN</code>: Sudan's view on the Halaib Triangle</p></li>
    /// <li>
    /// <p><code>SRB</code>: Serbia's view on Kosovo, Vukovar, and Sarengrad Islands</p></li>
    /// <li>
    /// <p><code>SUR</code>: Suriname's view on the Courantyne Headwaters and Lawa Headwaters</p></li>
    /// <li>
    /// <p><code>SYR</code>: Syria's view on the Golan Heights</p></li>
    /// <li>
    /// <p><code>TUR</code>: Turkey's view on Cyprus and Northern Cyprus</p></li>
    /// <li>
    /// <p><code>TZA</code>: Tanzania's view on Lake Malawi</p></li>
    /// <li>
    /// <p><code>URY</code>: Uruguay's view on Rincon de Artigas</p></li>
    /// <li>
    /// <p><code>VNM</code>: Vietnam's view on the Paracel Islands and Spratly Islands</p></li>
    /// </ul>
    pub fn get_political_view(&self) -> &::std::option::Option<::std::string::String> {
        self.inner.get_political_view()
    }
    /// <p>Indicates if the results will be stored. Defaults to <code>SingleUse</code>, if left empty.</p>
    pub fn intended_use(mut self, input: crate::types::AutocompleteIntendedUse) -> Self {
        self.inner = self.inner.intended_use(input);
        self
    }
    /// <p>Indicates if the results will be stored. Defaults to <code>SingleUse</code>, if left empty.</p>
    pub fn set_intended_use(mut self, input: ::std::option::Option<crate::types::AutocompleteIntendedUse>) -> Self {
        self.inner = self.inner.set_intended_use(input);
        self
    }
    /// <p>Indicates if the results will be stored. Defaults to <code>SingleUse</code>, if left empty.</p>
    pub fn get_intended_use(&self) -> &::std::option::Option<crate::types::AutocompleteIntendedUse> {
        self.inner.get_intended_use()
    }
    /// <p>Optional: The API key to be used for authorization. Either an API key or valid SigV4 signature must be provided when making a request.</p>
    pub fn key(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.inner = self.inner.key(input.into());
        self
    }
    /// <p>Optional: The API key to be used for authorization. Either an API key or valid SigV4 signature must be provided when making a request.</p>
    pub fn set_key(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.inner = self.inner.set_key(input);
        self
    }
    /// <p>Optional: The API key to be used for authorization. Either an API key or valid SigV4 signature must be provided when making a request.</p>
    pub fn get_key(&self) -> &::std::option::Option<::std::string::String> {
        self.inner.get_key()
    }
}
