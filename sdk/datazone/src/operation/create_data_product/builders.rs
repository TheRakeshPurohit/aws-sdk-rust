// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
pub use crate::operation::create_data_product::_create_data_product_output::CreateDataProductOutputBuilder;

pub use crate::operation::create_data_product::_create_data_product_input::CreateDataProductInputBuilder;

impl crate::operation::create_data_product::builders::CreateDataProductInputBuilder {
    /// Sends a request with this input using the given client.
    pub async fn send_with(
        self,
        client: &crate::Client,
    ) -> ::std::result::Result<
        crate::operation::create_data_product::CreateDataProductOutput,
        ::aws_smithy_runtime_api::client::result::SdkError<
            crate::operation::create_data_product::CreateDataProductError,
            ::aws_smithy_runtime_api::client::orchestrator::HttpResponse,
        >,
    > {
        let mut fluent_builder = client.create_data_product();
        fluent_builder.inner = self;
        fluent_builder.send().await
    }
}
/// Fluent builder constructing a request to `CreateDataProduct`.
///
/// <p>Creates a data product.</p>
/// <p>A data product is a comprehensive package that combines data assets with their associated metadata, documentation, and access controls. It's designed to serve specific business needs or use cases, making it easier for users to find and consume data appropriately. Data products include important information about data quality, freshness, and usage guidelines, effectively bridging the gap between data producers and consumers while ensuring proper governance.</p>
/// <p>Prerequisites:</p>
/// <ul>
/// <li>
/// <p>The domain must exist and be accessible.</p></li>
/// <li>
/// <p>The owning project must be valid and active.</p></li>
/// <li>
/// <p>The name must be unique within the domain (no existing data product with the same name).</p></li>
/// <li>
/// <p>User must have create permissions for data products in the project.</p></li>
/// </ul>
#[derive(::std::clone::Clone, ::std::fmt::Debug)]
pub struct CreateDataProductFluentBuilder {
    handle: ::std::sync::Arc<crate::client::Handle>,
    inner: crate::operation::create_data_product::builders::CreateDataProductInputBuilder,
    config_override: ::std::option::Option<crate::config::Builder>,
}
impl
    crate::client::customize::internal::CustomizableSend<
        crate::operation::create_data_product::CreateDataProductOutput,
        crate::operation::create_data_product::CreateDataProductError,
    > for CreateDataProductFluentBuilder
{
    fn send(
        self,
        config_override: crate::config::Builder,
    ) -> crate::client::customize::internal::BoxFuture<
        crate::client::customize::internal::SendResult<
            crate::operation::create_data_product::CreateDataProductOutput,
            crate::operation::create_data_product::CreateDataProductError,
        >,
    > {
        ::std::boxed::Box::pin(async move { self.config_override(config_override).send().await })
    }
}
impl CreateDataProductFluentBuilder {
    /// Creates a new `CreateDataProductFluentBuilder`.
    pub(crate) fn new(handle: ::std::sync::Arc<crate::client::Handle>) -> Self {
        Self {
            handle,
            inner: ::std::default::Default::default(),
            config_override: ::std::option::Option::None,
        }
    }
    /// Access the CreateDataProduct as a reference.
    pub fn as_input(&self) -> &crate::operation::create_data_product::builders::CreateDataProductInputBuilder {
        &self.inner
    }
    /// Sends the request and returns the response.
    ///
    /// If an error occurs, an `SdkError` will be returned with additional details that
    /// can be matched against.
    ///
    /// By default, any retryable failures will be retried twice. Retry behavior
    /// is configurable with the [RetryConfig](aws_smithy_types::retry::RetryConfig), which can be
    /// set when configuring the client.
    pub async fn send(
        self,
    ) -> ::std::result::Result<
        crate::operation::create_data_product::CreateDataProductOutput,
        ::aws_smithy_runtime_api::client::result::SdkError<
            crate::operation::create_data_product::CreateDataProductError,
            ::aws_smithy_runtime_api::client::orchestrator::HttpResponse,
        >,
    > {
        let input = self
            .inner
            .build()
            .map_err(::aws_smithy_runtime_api::client::result::SdkError::construction_failure)?;
        let runtime_plugins = crate::operation::create_data_product::CreateDataProduct::operation_runtime_plugins(
            self.handle.runtime_plugins.clone(),
            &self.handle.conf,
            self.config_override,
        );
        crate::operation::create_data_product::CreateDataProduct::orchestrate(&runtime_plugins, input).await
    }

    /// Consumes this builder, creating a customizable operation that can be modified before being sent.
    pub fn customize(
        self,
    ) -> crate::client::customize::CustomizableOperation<
        crate::operation::create_data_product::CreateDataProductOutput,
        crate::operation::create_data_product::CreateDataProductError,
        Self,
    > {
        crate::client::customize::CustomizableOperation::new(self)
    }
    pub(crate) fn config_override(mut self, config_override: impl ::std::convert::Into<crate::config::Builder>) -> Self {
        self.set_config_override(::std::option::Option::Some(config_override.into()));
        self
    }

    pub(crate) fn set_config_override(&mut self, config_override: ::std::option::Option<crate::config::Builder>) -> &mut Self {
        self.config_override = config_override;
        self
    }
    /// <p>The ID of the domain where the data product is created.</p>
    pub fn domain_identifier(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.inner = self.inner.domain_identifier(input.into());
        self
    }
    /// <p>The ID of the domain where the data product is created.</p>
    pub fn set_domain_identifier(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.inner = self.inner.set_domain_identifier(input);
        self
    }
    /// <p>The ID of the domain where the data product is created.</p>
    pub fn get_domain_identifier(&self) -> &::std::option::Option<::std::string::String> {
        self.inner.get_domain_identifier()
    }
    /// <p>The name of the data product.</p>
    pub fn name(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.inner = self.inner.name(input.into());
        self
    }
    /// <p>The name of the data product.</p>
    pub fn set_name(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.inner = self.inner.set_name(input);
        self
    }
    /// <p>The name of the data product.</p>
    pub fn get_name(&self) -> &::std::option::Option<::std::string::String> {
        self.inner.get_name()
    }
    /// <p>The ID of the owning project of the data product.</p>
    pub fn owning_project_identifier(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.inner = self.inner.owning_project_identifier(input.into());
        self
    }
    /// <p>The ID of the owning project of the data product.</p>
    pub fn set_owning_project_identifier(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.inner = self.inner.set_owning_project_identifier(input);
        self
    }
    /// <p>The ID of the owning project of the data product.</p>
    pub fn get_owning_project_identifier(&self) -> &::std::option::Option<::std::string::String> {
        self.inner.get_owning_project_identifier()
    }
    /// <p>The description of the data product.</p>
    pub fn description(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.inner = self.inner.description(input.into());
        self
    }
    /// <p>The description of the data product.</p>
    pub fn set_description(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.inner = self.inner.set_description(input);
        self
    }
    /// <p>The description of the data product.</p>
    pub fn get_description(&self) -> &::std::option::Option<::std::string::String> {
        self.inner.get_description()
    }
    ///
    /// Appends an item to `glossaryTerms`.
    ///
    /// To override the contents of this collection use [`set_glossary_terms`](Self::set_glossary_terms).
    ///
    /// <p>The glossary terms of the data product.</p>
    pub fn glossary_terms(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.inner = self.inner.glossary_terms(input.into());
        self
    }
    /// <p>The glossary terms of the data product.</p>
    pub fn set_glossary_terms(mut self, input: ::std::option::Option<::std::vec::Vec<::std::string::String>>) -> Self {
        self.inner = self.inner.set_glossary_terms(input);
        self
    }
    /// <p>The glossary terms of the data product.</p>
    pub fn get_glossary_terms(&self) -> &::std::option::Option<::std::vec::Vec<::std::string::String>> {
        self.inner.get_glossary_terms()
    }
    ///
    /// Appends an item to `formsInput`.
    ///
    /// To override the contents of this collection use [`set_forms_input`](Self::set_forms_input).
    ///
    /// <p>The metadata forms of the data product.</p>
    pub fn forms_input(mut self, input: crate::types::FormInput) -> Self {
        self.inner = self.inner.forms_input(input);
        self
    }
    /// <p>The metadata forms of the data product.</p>
    pub fn set_forms_input(mut self, input: ::std::option::Option<::std::vec::Vec<crate::types::FormInput>>) -> Self {
        self.inner = self.inner.set_forms_input(input);
        self
    }
    /// <p>The metadata forms of the data product.</p>
    pub fn get_forms_input(&self) -> &::std::option::Option<::std::vec::Vec<crate::types::FormInput>> {
        self.inner.get_forms_input()
    }
    ///
    /// Appends an item to `items`.
    ///
    /// To override the contents of this collection use [`set_items`](Self::set_items).
    ///
    /// <p>The data assets of the data product.</p>
    pub fn items(mut self, input: crate::types::DataProductItem) -> Self {
        self.inner = self.inner.items(input);
        self
    }
    /// <p>The data assets of the data product.</p>
    pub fn set_items(mut self, input: ::std::option::Option<::std::vec::Vec<crate::types::DataProductItem>>) -> Self {
        self.inner = self.inner.set_items(input);
        self
    }
    /// <p>The data assets of the data product.</p>
    pub fn get_items(&self) -> &::std::option::Option<::std::vec::Vec<crate::types::DataProductItem>> {
        self.inner.get_items()
    }
    /// <p>A unique, case-sensitive identifier that is provided to ensure the idempotency of the request.</p>
    pub fn client_token(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.inner = self.inner.client_token(input.into());
        self
    }
    /// <p>A unique, case-sensitive identifier that is provided to ensure the idempotency of the request.</p>
    pub fn set_client_token(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.inner = self.inner.set_client_token(input);
        self
    }
    /// <p>A unique, case-sensitive identifier that is provided to ensure the idempotency of the request.</p>
    pub fn get_client_token(&self) -> &::std::option::Option<::std::string::String> {
        self.inner.get_client_token()
    }
}
