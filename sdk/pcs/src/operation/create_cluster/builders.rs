// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
pub use crate::operation::create_cluster::_create_cluster_output::CreateClusterOutputBuilder;

pub use crate::operation::create_cluster::_create_cluster_input::CreateClusterInputBuilder;

impl crate::operation::create_cluster::builders::CreateClusterInputBuilder {
    /// Sends a request with this input using the given client.
    pub async fn send_with(
        self,
        client: &crate::Client,
    ) -> ::std::result::Result<
        crate::operation::create_cluster::CreateClusterOutput,
        ::aws_smithy_runtime_api::client::result::SdkError<
            crate::operation::create_cluster::CreateClusterError,
            ::aws_smithy_runtime_api::client::orchestrator::HttpResponse,
        >,
    > {
        let mut fluent_builder = client.create_cluster();
        fluent_builder.inner = self;
        fluent_builder.send().await
    }
}
/// Fluent builder constructing a request to `CreateCluster`.
///
/// <p>Creates a cluster in your account. PCS creates the cluster controller in a service-owned account. The cluster controller communicates with the cluster resources in your account. The subnets and security groups for the cluster must already exist before you use this API action.</p><note>
/// <p>It takes time for PCS to create the cluster. The cluster is in a <code>Creating</code> state until it is ready to use. There can only be 1 cluster in a <code>Creating</code> state per Amazon Web Services Region per Amazon Web Services account. <code>CreateCluster</code> fails with a <code>ServiceQuotaExceededException</code> if there is already a cluster in a <code>Creating</code> state.</p>
/// </note>
#[derive(::std::clone::Clone, ::std::fmt::Debug)]
pub struct CreateClusterFluentBuilder {
    handle: ::std::sync::Arc<crate::client::Handle>,
    inner: crate::operation::create_cluster::builders::CreateClusterInputBuilder,
    config_override: ::std::option::Option<crate::config::Builder>,
}
impl
    crate::client::customize::internal::CustomizableSend<
        crate::operation::create_cluster::CreateClusterOutput,
        crate::operation::create_cluster::CreateClusterError,
    > for CreateClusterFluentBuilder
{
    fn send(
        self,
        config_override: crate::config::Builder,
    ) -> crate::client::customize::internal::BoxFuture<
        crate::client::customize::internal::SendResult<
            crate::operation::create_cluster::CreateClusterOutput,
            crate::operation::create_cluster::CreateClusterError,
        >,
    > {
        ::std::boxed::Box::pin(async move { self.config_override(config_override).send().await })
    }
}
impl CreateClusterFluentBuilder {
    /// Creates a new `CreateClusterFluentBuilder`.
    pub(crate) fn new(handle: ::std::sync::Arc<crate::client::Handle>) -> Self {
        Self {
            handle,
            inner: ::std::default::Default::default(),
            config_override: ::std::option::Option::None,
        }
    }
    /// Access the CreateCluster as a reference.
    pub fn as_input(&self) -> &crate::operation::create_cluster::builders::CreateClusterInputBuilder {
        &self.inner
    }
    /// Sends the request and returns the response.
    ///
    /// If an error occurs, an `SdkError` will be returned with additional details that
    /// can be matched against.
    ///
    /// By default, any retryable failures will be retried twice. Retry behavior
    /// is configurable with the [RetryConfig](aws_smithy_types::retry::RetryConfig), which can be
    /// set when configuring the client.
    pub async fn send(
        self,
    ) -> ::std::result::Result<
        crate::operation::create_cluster::CreateClusterOutput,
        ::aws_smithy_runtime_api::client::result::SdkError<
            crate::operation::create_cluster::CreateClusterError,
            ::aws_smithy_runtime_api::client::orchestrator::HttpResponse,
        >,
    > {
        let input = self
            .inner
            .build()
            .map_err(::aws_smithy_runtime_api::client::result::SdkError::construction_failure)?;
        let runtime_plugins = crate::operation::create_cluster::CreateCluster::operation_runtime_plugins(
            self.handle.runtime_plugins.clone(),
            &self.handle.conf,
            self.config_override,
        );
        crate::operation::create_cluster::CreateCluster::orchestrate(&runtime_plugins, input).await
    }

    /// Consumes this builder, creating a customizable operation that can be modified before being sent.
    pub fn customize(
        self,
    ) -> crate::client::customize::CustomizableOperation<
        crate::operation::create_cluster::CreateClusterOutput,
        crate::operation::create_cluster::CreateClusterError,
        Self,
    > {
        crate::client::customize::CustomizableOperation::new(self)
    }
    pub(crate) fn config_override(mut self, config_override: impl ::std::convert::Into<crate::config::Builder>) -> Self {
        self.set_config_override(::std::option::Option::Some(config_override.into()));
        self
    }

    pub(crate) fn set_config_override(&mut self, config_override: ::std::option::Option<crate::config::Builder>) -> &mut Self {
        self.config_override = config_override;
        self
    }
    /// <p>A name to identify the cluster. Example: <code>MyCluster</code></p>
    pub fn cluster_name(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.inner = self.inner.cluster_name(input.into());
        self
    }
    /// <p>A name to identify the cluster. Example: <code>MyCluster</code></p>
    pub fn set_cluster_name(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.inner = self.inner.set_cluster_name(input);
        self
    }
    /// <p>A name to identify the cluster. Example: <code>MyCluster</code></p>
    pub fn get_cluster_name(&self) -> &::std::option::Option<::std::string::String> {
        self.inner.get_cluster_name()
    }
    /// <p>The cluster management and job scheduling software associated with the cluster.</p>
    pub fn scheduler(mut self, input: crate::types::SchedulerRequest) -> Self {
        self.inner = self.inner.scheduler(input);
        self
    }
    /// <p>The cluster management and job scheduling software associated with the cluster.</p>
    pub fn set_scheduler(mut self, input: ::std::option::Option<crate::types::SchedulerRequest>) -> Self {
        self.inner = self.inner.set_scheduler(input);
        self
    }
    /// <p>The cluster management and job scheduling software associated with the cluster.</p>
    pub fn get_scheduler(&self) -> &::std::option::Option<crate::types::SchedulerRequest> {
        self.inner.get_scheduler()
    }
    /// <p>A value that determines the maximum number of compute nodes in the cluster and the maximum number of jobs (active and queued).</p>
    /// <ul>
    /// <li>
    /// <p><code>SMALL</code>: 32 compute nodes and 256 jobs</p></li>
    /// <li>
    /// <p><code>MEDIUM</code>: 512 compute nodes and 8192 jobs</p></li>
    /// <li>
    /// <p><code>LARGE</code>: 2048 compute nodes and 16,384 jobs</p></li>
    /// </ul>
    pub fn size(mut self, input: crate::types::Size) -> Self {
        self.inner = self.inner.size(input);
        self
    }
    /// <p>A value that determines the maximum number of compute nodes in the cluster and the maximum number of jobs (active and queued).</p>
    /// <ul>
    /// <li>
    /// <p><code>SMALL</code>: 32 compute nodes and 256 jobs</p></li>
    /// <li>
    /// <p><code>MEDIUM</code>: 512 compute nodes and 8192 jobs</p></li>
    /// <li>
    /// <p><code>LARGE</code>: 2048 compute nodes and 16,384 jobs</p></li>
    /// </ul>
    pub fn set_size(mut self, input: ::std::option::Option<crate::types::Size>) -> Self {
        self.inner = self.inner.set_size(input);
        self
    }
    /// <p>A value that determines the maximum number of compute nodes in the cluster and the maximum number of jobs (active and queued).</p>
    /// <ul>
    /// <li>
    /// <p><code>SMALL</code>: 32 compute nodes and 256 jobs</p></li>
    /// <li>
    /// <p><code>MEDIUM</code>: 512 compute nodes and 8192 jobs</p></li>
    /// <li>
    /// <p><code>LARGE</code>: 2048 compute nodes and 16,384 jobs</p></li>
    /// </ul>
    pub fn get_size(&self) -> &::std::option::Option<crate::types::Size> {
        self.inner.get_size()
    }
    /// <p>The networking configuration used to set up the cluster's control plane.</p>
    pub fn networking(mut self, input: crate::types::NetworkingRequest) -> Self {
        self.inner = self.inner.networking(input);
        self
    }
    /// <p>The networking configuration used to set up the cluster's control plane.</p>
    pub fn set_networking(mut self, input: ::std::option::Option<crate::types::NetworkingRequest>) -> Self {
        self.inner = self.inner.set_networking(input);
        self
    }
    /// <p>The networking configuration used to set up the cluster's control plane.</p>
    pub fn get_networking(&self) -> &::std::option::Option<crate::types::NetworkingRequest> {
        self.inner.get_networking()
    }
    /// <p>Additional options related to the Slurm scheduler.</p>
    pub fn slurm_configuration(mut self, input: crate::types::ClusterSlurmConfigurationRequest) -> Self {
        self.inner = self.inner.slurm_configuration(input);
        self
    }
    /// <p>Additional options related to the Slurm scheduler.</p>
    pub fn set_slurm_configuration(mut self, input: ::std::option::Option<crate::types::ClusterSlurmConfigurationRequest>) -> Self {
        self.inner = self.inner.set_slurm_configuration(input);
        self
    }
    /// <p>Additional options related to the Slurm scheduler.</p>
    pub fn get_slurm_configuration(&self) -> &::std::option::Option<crate::types::ClusterSlurmConfigurationRequest> {
        self.inner.get_slurm_configuration()
    }
    /// <p>A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. Idempotency ensures that an API request completes only once. With an idempotent request, if the original request completes successfully, the subsequent retries with the same client token return the result from the original successful request and they have no additional effect. If you don't specify a client token, the CLI and SDK automatically generate 1 for you.</p>
    pub fn client_token(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.inner = self.inner.client_token(input.into());
        self
    }
    /// <p>A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. Idempotency ensures that an API request completes only once. With an idempotent request, if the original request completes successfully, the subsequent retries with the same client token return the result from the original successful request and they have no additional effect. If you don't specify a client token, the CLI and SDK automatically generate 1 for you.</p>
    pub fn set_client_token(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.inner = self.inner.set_client_token(input);
        self
    }
    /// <p>A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. Idempotency ensures that an API request completes only once. With an idempotent request, if the original request completes successfully, the subsequent retries with the same client token return the result from the original successful request and they have no additional effect. If you don't specify a client token, the CLI and SDK automatically generate 1 for you.</p>
    pub fn get_client_token(&self) -> &::std::option::Option<::std::string::String> {
        self.inner.get_client_token()
    }
    ///
    /// Adds a key-value pair to `tags`.
    ///
    /// To override the contents of this collection use [`set_tags`](Self::set_tags).
    ///
    /// <p>1 or more tags added to the resource. Each tag consists of a tag key and tag value. The tag value is optional and can be an empty string.</p>
    pub fn tags(mut self, k: impl ::std::convert::Into<::std::string::String>, v: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.inner = self.inner.tags(k.into(), v.into());
        self
    }
    /// <p>1 or more tags added to the resource. Each tag consists of a tag key and tag value. The tag value is optional and can be an empty string.</p>
    pub fn set_tags(mut self, input: ::std::option::Option<::std::collections::HashMap<::std::string::String, ::std::string::String>>) -> Self {
        self.inner = self.inner.set_tags(input);
        self
    }
    /// <p>1 or more tags added to the resource. Each tag consists of a tag key and tag value. The tag value is optional and can be an empty string.</p>
    pub fn get_tags(&self) -> &::std::option::Option<::std::collections::HashMap<::std::string::String, ::std::string::String>> {
        self.inner.get_tags()
    }
}
