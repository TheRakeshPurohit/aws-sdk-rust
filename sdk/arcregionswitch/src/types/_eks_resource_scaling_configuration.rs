// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.

/// <p>The Amazon Web Services EKS resource scaling configuration.</p>
#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::fmt::Debug)]
pub struct EksResourceScalingConfiguration {
    /// <p>The timeout value specified for the configuration.</p>
    pub timeout_minutes: i32,
    /// <p>The Kubernetes resource type for the configuration.</p>
    pub kubernetes_resource_type: ::std::option::Option<crate::types::KubernetesResourceType>,
    /// <p>The scaling resources for the configuration.</p>
    pub scaling_resources: ::std::option::Option<
        ::std::vec::Vec<
            ::std::collections::HashMap<
                ::std::string::String,
                ::std::collections::HashMap<::std::string::String, crate::types::KubernetesScalingResource>,
            >,
        >,
    >,
    /// <p>The clusters for the configuration.</p>
    pub eks_clusters: ::std::option::Option<::std::vec::Vec<crate::types::EksCluster>>,
    /// <p>The settings for ungraceful execution.</p>
    pub ungraceful: ::std::option::Option<crate::types::EksResourceScalingUngraceful>,
    /// <p>The target percentage for the configuration.</p>
    pub target_percent: i32,
    /// <p>The monitoring approach for the configuration, that is, whether it was sampled in the last 24 hours or autoscaled in the last 24 hours.</p>
    pub capacity_monitoring_approach: crate::types::EksCapacityMonitoringApproach,
}
impl EksResourceScalingConfiguration {
    /// <p>The timeout value specified for the configuration.</p>
    pub fn timeout_minutes(&self) -> i32 {
        self.timeout_minutes
    }
    /// <p>The Kubernetes resource type for the configuration.</p>
    pub fn kubernetes_resource_type(&self) -> ::std::option::Option<&crate::types::KubernetesResourceType> {
        self.kubernetes_resource_type.as_ref()
    }
    /// <p>The scaling resources for the configuration.</p>
    ///
    /// If no value was sent for this field, a default will be set. If you want to determine if no value was sent, use `.scaling_resources.is_none()`.
    pub fn scaling_resources(
        &self,
    ) -> &[::std::collections::HashMap<
        ::std::string::String,
        ::std::collections::HashMap<::std::string::String, crate::types::KubernetesScalingResource>,
    >] {
        self.scaling_resources.as_deref().unwrap_or_default()
    }
    /// <p>The clusters for the configuration.</p>
    ///
    /// If no value was sent for this field, a default will be set. If you want to determine if no value was sent, use `.eks_clusters.is_none()`.
    pub fn eks_clusters(&self) -> &[crate::types::EksCluster] {
        self.eks_clusters.as_deref().unwrap_or_default()
    }
    /// <p>The settings for ungraceful execution.</p>
    pub fn ungraceful(&self) -> ::std::option::Option<&crate::types::EksResourceScalingUngraceful> {
        self.ungraceful.as_ref()
    }
    /// <p>The target percentage for the configuration.</p>
    pub fn target_percent(&self) -> i32 {
        self.target_percent
    }
    /// <p>The monitoring approach for the configuration, that is, whether it was sampled in the last 24 hours or autoscaled in the last 24 hours.</p>
    pub fn capacity_monitoring_approach(&self) -> &crate::types::EksCapacityMonitoringApproach {
        &self.capacity_monitoring_approach
    }
}
impl EksResourceScalingConfiguration {
    /// Creates a new builder-style object to manufacture [`EksResourceScalingConfiguration`](crate::types::EksResourceScalingConfiguration).
    pub fn builder() -> crate::types::builders::EksResourceScalingConfigurationBuilder {
        crate::types::builders::EksResourceScalingConfigurationBuilder::default()
    }
}

/// A builder for [`EksResourceScalingConfiguration`](crate::types::EksResourceScalingConfiguration).
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::default::Default, ::std::fmt::Debug)]
#[non_exhaustive]
pub struct EksResourceScalingConfigurationBuilder {
    pub(crate) timeout_minutes: ::std::option::Option<i32>,
    pub(crate) kubernetes_resource_type: ::std::option::Option<crate::types::KubernetesResourceType>,
    pub(crate) scaling_resources: ::std::option::Option<
        ::std::vec::Vec<
            ::std::collections::HashMap<
                ::std::string::String,
                ::std::collections::HashMap<::std::string::String, crate::types::KubernetesScalingResource>,
            >,
        >,
    >,
    pub(crate) eks_clusters: ::std::option::Option<::std::vec::Vec<crate::types::EksCluster>>,
    pub(crate) ungraceful: ::std::option::Option<crate::types::EksResourceScalingUngraceful>,
    pub(crate) target_percent: ::std::option::Option<i32>,
    pub(crate) capacity_monitoring_approach: ::std::option::Option<crate::types::EksCapacityMonitoringApproach>,
}
impl EksResourceScalingConfigurationBuilder {
    /// <p>The timeout value specified for the configuration.</p>
    pub fn timeout_minutes(mut self, input: i32) -> Self {
        self.timeout_minutes = ::std::option::Option::Some(input);
        self
    }
    /// <p>The timeout value specified for the configuration.</p>
    pub fn set_timeout_minutes(mut self, input: ::std::option::Option<i32>) -> Self {
        self.timeout_minutes = input;
        self
    }
    /// <p>The timeout value specified for the configuration.</p>
    pub fn get_timeout_minutes(&self) -> &::std::option::Option<i32> {
        &self.timeout_minutes
    }
    /// <p>The Kubernetes resource type for the configuration.</p>
    /// This field is required.
    pub fn kubernetes_resource_type(mut self, input: crate::types::KubernetesResourceType) -> Self {
        self.kubernetes_resource_type = ::std::option::Option::Some(input);
        self
    }
    /// <p>The Kubernetes resource type for the configuration.</p>
    pub fn set_kubernetes_resource_type(mut self, input: ::std::option::Option<crate::types::KubernetesResourceType>) -> Self {
        self.kubernetes_resource_type = input;
        self
    }
    /// <p>The Kubernetes resource type for the configuration.</p>
    pub fn get_kubernetes_resource_type(&self) -> &::std::option::Option<crate::types::KubernetesResourceType> {
        &self.kubernetes_resource_type
    }
    /// Appends an item to `scaling_resources`.
    ///
    /// To override the contents of this collection use [`set_scaling_resources`](Self::set_scaling_resources).
    ///
    /// <p>The scaling resources for the configuration.</p>
    pub fn scaling_resources(
        mut self,
        input: ::std::collections::HashMap<
            ::std::string::String,
            ::std::collections::HashMap<::std::string::String, crate::types::KubernetesScalingResource>,
        >,
    ) -> Self {
        let mut v = self.scaling_resources.unwrap_or_default();
        v.push(input);
        self.scaling_resources = ::std::option::Option::Some(v);
        self
    }
    /// <p>The scaling resources for the configuration.</p>
    pub fn set_scaling_resources(
        mut self,
        input: ::std::option::Option<
            ::std::vec::Vec<
                ::std::collections::HashMap<
                    ::std::string::String,
                    ::std::collections::HashMap<::std::string::String, crate::types::KubernetesScalingResource>,
                >,
            >,
        >,
    ) -> Self {
        self.scaling_resources = input;
        self
    }
    /// <p>The scaling resources for the configuration.</p>
    pub fn get_scaling_resources(
        &self,
    ) -> &::std::option::Option<
        ::std::vec::Vec<
            ::std::collections::HashMap<
                ::std::string::String,
                ::std::collections::HashMap<::std::string::String, crate::types::KubernetesScalingResource>,
            >,
        >,
    > {
        &self.scaling_resources
    }
    /// Appends an item to `eks_clusters`.
    ///
    /// To override the contents of this collection use [`set_eks_clusters`](Self::set_eks_clusters).
    ///
    /// <p>The clusters for the configuration.</p>
    pub fn eks_clusters(mut self, input: crate::types::EksCluster) -> Self {
        let mut v = self.eks_clusters.unwrap_or_default();
        v.push(input);
        self.eks_clusters = ::std::option::Option::Some(v);
        self
    }
    /// <p>The clusters for the configuration.</p>
    pub fn set_eks_clusters(mut self, input: ::std::option::Option<::std::vec::Vec<crate::types::EksCluster>>) -> Self {
        self.eks_clusters = input;
        self
    }
    /// <p>The clusters for the configuration.</p>
    pub fn get_eks_clusters(&self) -> &::std::option::Option<::std::vec::Vec<crate::types::EksCluster>> {
        &self.eks_clusters
    }
    /// <p>The settings for ungraceful execution.</p>
    pub fn ungraceful(mut self, input: crate::types::EksResourceScalingUngraceful) -> Self {
        self.ungraceful = ::std::option::Option::Some(input);
        self
    }
    /// <p>The settings for ungraceful execution.</p>
    pub fn set_ungraceful(mut self, input: ::std::option::Option<crate::types::EksResourceScalingUngraceful>) -> Self {
        self.ungraceful = input;
        self
    }
    /// <p>The settings for ungraceful execution.</p>
    pub fn get_ungraceful(&self) -> &::std::option::Option<crate::types::EksResourceScalingUngraceful> {
        &self.ungraceful
    }
    /// <p>The target percentage for the configuration.</p>
    pub fn target_percent(mut self, input: i32) -> Self {
        self.target_percent = ::std::option::Option::Some(input);
        self
    }
    /// <p>The target percentage for the configuration.</p>
    pub fn set_target_percent(mut self, input: ::std::option::Option<i32>) -> Self {
        self.target_percent = input;
        self
    }
    /// <p>The target percentage for the configuration.</p>
    pub fn get_target_percent(&self) -> &::std::option::Option<i32> {
        &self.target_percent
    }
    /// <p>The monitoring approach for the configuration, that is, whether it was sampled in the last 24 hours or autoscaled in the last 24 hours.</p>
    pub fn capacity_monitoring_approach(mut self, input: crate::types::EksCapacityMonitoringApproach) -> Self {
        self.capacity_monitoring_approach = ::std::option::Option::Some(input);
        self
    }
    /// <p>The monitoring approach for the configuration, that is, whether it was sampled in the last 24 hours or autoscaled in the last 24 hours.</p>
    pub fn set_capacity_monitoring_approach(mut self, input: ::std::option::Option<crate::types::EksCapacityMonitoringApproach>) -> Self {
        self.capacity_monitoring_approach = input;
        self
    }
    /// <p>The monitoring approach for the configuration, that is, whether it was sampled in the last 24 hours or autoscaled in the last 24 hours.</p>
    pub fn get_capacity_monitoring_approach(&self) -> &::std::option::Option<crate::types::EksCapacityMonitoringApproach> {
        &self.capacity_monitoring_approach
    }
    /// Consumes the builder and constructs a [`EksResourceScalingConfiguration`](crate::types::EksResourceScalingConfiguration).
    pub fn build(self) -> crate::types::EksResourceScalingConfiguration {
        crate::types::EksResourceScalingConfiguration {
            timeout_minutes: self.timeout_minutes.unwrap_or(60),
            kubernetes_resource_type: self.kubernetes_resource_type,
            scaling_resources: self.scaling_resources,
            eks_clusters: self.eks_clusters,
            ungraceful: self.ungraceful,
            target_percent: self.target_percent.unwrap_or(100),
            capacity_monitoring_approach: self.capacity_monitoring_approach.unwrap_or(
                "sampledMaxInLast24Hours"
                    .parse::<crate::types::EksCapacityMonitoringApproach>()
                    .expect("static value validated to member"),
            ),
        }
    }
}
