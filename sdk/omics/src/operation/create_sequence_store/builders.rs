// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
pub use crate::operation::create_sequence_store::_create_sequence_store_output::CreateSequenceStoreOutputBuilder;

pub use crate::operation::create_sequence_store::_create_sequence_store_input::CreateSequenceStoreInputBuilder;

impl crate::operation::create_sequence_store::builders::CreateSequenceStoreInputBuilder {
    /// Sends a request with this input using the given client.
    pub async fn send_with(
        self,
        client: &crate::Client,
    ) -> ::std::result::Result<
        crate::operation::create_sequence_store::CreateSequenceStoreOutput,
        ::aws_smithy_runtime_api::client::result::SdkError<
            crate::operation::create_sequence_store::CreateSequenceStoreError,
            ::aws_smithy_runtime_api::client::orchestrator::HttpResponse,
        >,
    > {
        let mut fluent_builder = client.create_sequence_store();
        fluent_builder.inner = self;
        fluent_builder.send().await
    }
}
/// Fluent builder constructing a request to `CreateSequenceStore`.
///
/// <p>Creates a sequence store and returns its metadata. Sequence stores are used to store sequence data files called read sets that are saved in FASTQ, BAM, uBAM, or CRAM formats. For aligned formats (BAM and CRAM), a sequence store can only use one reference genome. For unaligned formats (FASTQ and uBAM), a reference genome is not required. You can create multiple sequence stores per region per account.</p>
/// <p>The following are optional parameters you can specify for your sequence store:</p>
/// <ul>
/// <li>
/// <p>Use <code>s3AccessConfig</code> to configure your sequence store with S3 access logs (recommended).</p></li>
/// <li>
/// <p>Use <code>sseConfig</code> to define your own KMS key for encryption.</p></li>
/// <li>
/// <p>Use <code>eTagAlgorithmFamily</code> to define which algorithm to use for the HealthOmics eTag on objects.</p></li>
/// <li>
/// <p>Use <code>fallbackLocation</code> to define a backup location for storing files that have failed a direct upload.</p></li>
/// <li>
/// <p>Use <code>propagatedSetLevelTags</code> to configure tags that propagate to all objects in your store.</p></li>
/// </ul>
/// <p>For more information, see <a href="https://docs.aws.amazon.com/omics/latest/dev/create-sequence-store.html">Creating a HealthOmics sequence store</a> in the <i>Amazon Web Services HealthOmics User Guide</i>.</p>
#[derive(::std::clone::Clone, ::std::fmt::Debug)]
pub struct CreateSequenceStoreFluentBuilder {
    handle: ::std::sync::Arc<crate::client::Handle>,
    inner: crate::operation::create_sequence_store::builders::CreateSequenceStoreInputBuilder,
    config_override: ::std::option::Option<crate::config::Builder>,
}
impl
    crate::client::customize::internal::CustomizableSend<
        crate::operation::create_sequence_store::CreateSequenceStoreOutput,
        crate::operation::create_sequence_store::CreateSequenceStoreError,
    > for CreateSequenceStoreFluentBuilder
{
    fn send(
        self,
        config_override: crate::config::Builder,
    ) -> crate::client::customize::internal::BoxFuture<
        crate::client::customize::internal::SendResult<
            crate::operation::create_sequence_store::CreateSequenceStoreOutput,
            crate::operation::create_sequence_store::CreateSequenceStoreError,
        >,
    > {
        ::std::boxed::Box::pin(async move { self.config_override(config_override).send().await })
    }
}
impl CreateSequenceStoreFluentBuilder {
    /// Creates a new `CreateSequenceStoreFluentBuilder`.
    pub(crate) fn new(handle: ::std::sync::Arc<crate::client::Handle>) -> Self {
        Self {
            handle,
            inner: ::std::default::Default::default(),
            config_override: ::std::option::Option::None,
        }
    }
    /// Access the CreateSequenceStore as a reference.
    pub fn as_input(&self) -> &crate::operation::create_sequence_store::builders::CreateSequenceStoreInputBuilder {
        &self.inner
    }
    /// Sends the request and returns the response.
    ///
    /// If an error occurs, an `SdkError` will be returned with additional details that
    /// can be matched against.
    ///
    /// By default, any retryable failures will be retried twice. Retry behavior
    /// is configurable with the [RetryConfig](aws_smithy_types::retry::RetryConfig), which can be
    /// set when configuring the client.
    pub async fn send(
        self,
    ) -> ::std::result::Result<
        crate::operation::create_sequence_store::CreateSequenceStoreOutput,
        ::aws_smithy_runtime_api::client::result::SdkError<
            crate::operation::create_sequence_store::CreateSequenceStoreError,
            ::aws_smithy_runtime_api::client::orchestrator::HttpResponse,
        >,
    > {
        let input = self
            .inner
            .build()
            .map_err(::aws_smithy_runtime_api::client::result::SdkError::construction_failure)?;
        let runtime_plugins = crate::operation::create_sequence_store::CreateSequenceStore::operation_runtime_plugins(
            self.handle.runtime_plugins.clone(),
            &self.handle.conf,
            self.config_override,
        );
        crate::operation::create_sequence_store::CreateSequenceStore::orchestrate(&runtime_plugins, input).await
    }

    /// Consumes this builder, creating a customizable operation that can be modified before being sent.
    pub fn customize(
        self,
    ) -> crate::client::customize::CustomizableOperation<
        crate::operation::create_sequence_store::CreateSequenceStoreOutput,
        crate::operation::create_sequence_store::CreateSequenceStoreError,
        Self,
    > {
        crate::client::customize::CustomizableOperation::new(self)
    }
    pub(crate) fn config_override(mut self, config_override: impl ::std::convert::Into<crate::config::Builder>) -> Self {
        self.set_config_override(::std::option::Option::Some(config_override.into()));
        self
    }

    pub(crate) fn set_config_override(&mut self, config_override: ::std::option::Option<crate::config::Builder>) -> &mut Self {
        self.config_override = config_override;
        self
    }
    /// <p>A name for the store.</p>
    pub fn name(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.inner = self.inner.name(input.into());
        self
    }
    /// <p>A name for the store.</p>
    pub fn set_name(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.inner = self.inner.set_name(input);
        self
    }
    /// <p>A name for the store.</p>
    pub fn get_name(&self) -> &::std::option::Option<::std::string::String> {
        self.inner.get_name()
    }
    /// <p>A description for the store.</p>
    pub fn description(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.inner = self.inner.description(input.into());
        self
    }
    /// <p>A description for the store.</p>
    pub fn set_description(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.inner = self.inner.set_description(input);
        self
    }
    /// <p>A description for the store.</p>
    pub fn get_description(&self) -> &::std::option::Option<::std::string::String> {
        self.inner.get_description()
    }
    /// <p>Server-side encryption (SSE) settings for the store.</p>
    pub fn sse_config(mut self, input: crate::types::SseConfig) -> Self {
        self.inner = self.inner.sse_config(input);
        self
    }
    /// <p>Server-side encryption (SSE) settings for the store.</p>
    pub fn set_sse_config(mut self, input: ::std::option::Option<crate::types::SseConfig>) -> Self {
        self.inner = self.inner.set_sse_config(input);
        self
    }
    /// <p>Server-side encryption (SSE) settings for the store.</p>
    pub fn get_sse_config(&self) -> &::std::option::Option<crate::types::SseConfig> {
        self.inner.get_sse_config()
    }
    ///
    /// Adds a key-value pair to `tags`.
    ///
    /// To override the contents of this collection use [`set_tags`](Self::set_tags).
    ///
    /// <p>Tags for the store. You can configure up to 50 tags.</p>
    pub fn tags(mut self, k: impl ::std::convert::Into<::std::string::String>, v: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.inner = self.inner.tags(k.into(), v.into());
        self
    }
    /// <p>Tags for the store. You can configure up to 50 tags.</p>
    pub fn set_tags(mut self, input: ::std::option::Option<::std::collections::HashMap<::std::string::String, ::std::string::String>>) -> Self {
        self.inner = self.inner.set_tags(input);
        self
    }
    /// <p>Tags for the store. You can configure up to 50 tags.</p>
    pub fn get_tags(&self) -> &::std::option::Option<::std::collections::HashMap<::std::string::String, ::std::string::String>> {
        self.inner.get_tags()
    }
    /// <p>An idempotency token used to dedupe retry requests so that duplicate runs are not created.</p>
    pub fn client_token(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.inner = self.inner.client_token(input.into());
        self
    }
    /// <p>An idempotency token used to dedupe retry requests so that duplicate runs are not created.</p>
    pub fn set_client_token(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.inner = self.inner.set_client_token(input);
        self
    }
    /// <p>An idempotency token used to dedupe retry requests so that duplicate runs are not created.</p>
    pub fn get_client_token(&self) -> &::std::option::Option<::std::string::String> {
        self.inner.get_client_token()
    }
    /// <p>An S3 location that is used to store files that have failed a direct upload. You can add or change the <code>fallbackLocation</code> after creating a sequence store. This is not required if you are uploading files from a different S3 bucket.</p>
    pub fn fallback_location(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.inner = self.inner.fallback_location(input.into());
        self
    }
    /// <p>An S3 location that is used to store files that have failed a direct upload. You can add or change the <code>fallbackLocation</code> after creating a sequence store. This is not required if you are uploading files from a different S3 bucket.</p>
    pub fn set_fallback_location(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.inner = self.inner.set_fallback_location(input);
        self
    }
    /// <p>An S3 location that is used to store files that have failed a direct upload. You can add or change the <code>fallbackLocation</code> after creating a sequence store. This is not required if you are uploading files from a different S3 bucket.</p>
    pub fn get_fallback_location(&self) -> &::std::option::Option<::std::string::String> {
        self.inner.get_fallback_location()
    }
    /// <p>The ETag algorithm family to use for ingested read sets. The default value is MD5up. For more information on ETags, see <a href="https://docs.aws.amazon.com/omics/latest/dev/etags-and-provenance.html">ETags and data provenance</a> in the <i>Amazon Web Services HealthOmics User Guide</i>.</p>
    pub fn e_tag_algorithm_family(mut self, input: crate::types::ETagAlgorithmFamily) -> Self {
        self.inner = self.inner.e_tag_algorithm_family(input);
        self
    }
    /// <p>The ETag algorithm family to use for ingested read sets. The default value is MD5up. For more information on ETags, see <a href="https://docs.aws.amazon.com/omics/latest/dev/etags-and-provenance.html">ETags and data provenance</a> in the <i>Amazon Web Services HealthOmics User Guide</i>.</p>
    pub fn set_e_tag_algorithm_family(mut self, input: ::std::option::Option<crate::types::ETagAlgorithmFamily>) -> Self {
        self.inner = self.inner.set_e_tag_algorithm_family(input);
        self
    }
    /// <p>The ETag algorithm family to use for ingested read sets. The default value is MD5up. For more information on ETags, see <a href="https://docs.aws.amazon.com/omics/latest/dev/etags-and-provenance.html">ETags and data provenance</a> in the <i>Amazon Web Services HealthOmics User Guide</i>.</p>
    pub fn get_e_tag_algorithm_family(&self) -> &::std::option::Option<crate::types::ETagAlgorithmFamily> {
        self.inner.get_e_tag_algorithm_family()
    }
    ///
    /// Appends an item to `propagatedSetLevelTags`.
    ///
    /// To override the contents of this collection use [`set_propagated_set_level_tags`](Self::set_propagated_set_level_tags).
    ///
    /// <p>The tags keys to propagate to the S3 objects associated with read sets in the sequence store. These tags can be used as input to add metadata to your read sets.</p>
    pub fn propagated_set_level_tags(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.inner = self.inner.propagated_set_level_tags(input.into());
        self
    }
    /// <p>The tags keys to propagate to the S3 objects associated with read sets in the sequence store. These tags can be used as input to add metadata to your read sets.</p>
    pub fn set_propagated_set_level_tags(mut self, input: ::std::option::Option<::std::vec::Vec<::std::string::String>>) -> Self {
        self.inner = self.inner.set_propagated_set_level_tags(input);
        self
    }
    /// <p>The tags keys to propagate to the S3 objects associated with read sets in the sequence store. These tags can be used as input to add metadata to your read sets.</p>
    pub fn get_propagated_set_level_tags(&self) -> &::std::option::Option<::std::vec::Vec<::std::string::String>> {
        self.inner.get_propagated_set_level_tags()
    }
    /// <p>S3 access configuration parameters. This specifies the parameters needed to access logs stored in S3 buckets. The S3 bucket must be in the same region and account as the sequence store.</p>
    pub fn s3_access_config(mut self, input: crate::types::S3AccessConfig) -> Self {
        self.inner = self.inner.s3_access_config(input);
        self
    }
    /// <p>S3 access configuration parameters. This specifies the parameters needed to access logs stored in S3 buckets. The S3 bucket must be in the same region and account as the sequence store.</p>
    pub fn set_s3_access_config(mut self, input: ::std::option::Option<crate::types::S3AccessConfig>) -> Self {
        self.inner = self.inner.set_s3_access_config(input);
        self
    }
    /// <p>S3 access configuration parameters. This specifies the parameters needed to access logs stored in S3 buckets. The S3 bucket must be in the same region and account as the sequence store.</p>
    pub fn get_s3_access_config(&self) -> &::std::option::Option<crate::types::S3AccessConfig> {
        self.inner.get_s3_access_config()
    }
}
